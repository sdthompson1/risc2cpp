-- MODULE:
--   Main
--
-- PURPOSE:
--   Main Program for Mips2cs
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   15-Oct-2010 (original version)
--   27-Dec-2010 (this version)
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011.
--
--   This file is part of Mips2cs. Mips2cs is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Main where

import Mips2cs.BasicBlock
import Mips2cs.CodeGen
import Mips2cs.ExtractCode
import Mips2cs.LocalVarAlloc
import Mips2cs.MipsToIntermed
import Mips2cs.Simplifier

import qualified Data.ByteString as B
import Data.Char
import Data.Elf
import Data.List
import qualified Data.Map as Map
import Data.Map (Map)
import System.Environment (getArgs)
import System.IO


-- Cmd line option parsing.
parseArgs :: [String] -> Maybe (Int, FilePath, FilePath)
parseArgs xs = do
  (ys, optLevel) <- parseOptions xs
  case ys of
    [inFile, outFile] -> Just (optLevel, inFile, outFile)
    _ -> Nothing

parseOptions :: [String] -> Maybe ([String], Int)
parseOptions args = do
  let (options, others) = partition isOption args
  optLevel <- extractOptLevel options
  return (others, optLevel)

isOption :: String -> Bool
isOption ('-':_) = True
isOption _ = False

extractOptLevel :: [String] -> Maybe Int
extractOptLevel [('-':'O':a)] | all isDigit a = Just $ read a
extractOptLevel [] = Just 1   -- default optimization level
extractOptLevel _ = Nothing


-- Main Function
main :: IO ()
main = do
  args <- getArgs
  case parseArgs args of 
    Nothing -> putStrLn "Usage: Mips2cs [-O<n>] <input file> <output file>"
    Just (optLevel, inFile, outFile) -> processFile optLevel inFile outFile


processFile :: Int -> FilePath -> FilePath -> IO ()
processFile optLevel inFile outFile = do
  byteString <- B.readFile inFile
  
  -- Open the ELF file
  let elf = parseElf byteString

  -- Extract code & data chunks, and jump targets
  let (jumpTargets, codeChunks, dataChunks) = extractCode elf     -- NB jumpTargets is unsorted & may contain duplicates.

  -- Convert code chunks to Intermediate form
  let (allJumpTargets, intermediateCode) = mipsToIntermed jumpTargets codeChunks

  -- Extract basic blocks.
  let (kernelAddrs, basicBlocks) = findBasicBlocks allJumpTargets intermediateCode

  -- Run optimization passes
  let simplified = simplify optLevel allJumpTargets kernelAddrs basicBlocks

  -- Generate the C# code
  let withLocVars = Map.map allocLocalVars simplified 
      code = codeGen withLocVars allJumpTargets kernelAddrs dataChunks (fromIntegral $ elfEntry elf)

  -- Save the results to the output file
  writeFile outFile (intercalate "\n" code)
