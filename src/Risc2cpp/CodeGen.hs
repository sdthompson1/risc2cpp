-- MODULE:
--   Risc2cpp.CodeGen
--
-- PURPOSE:
--   Generate C++ code from a list of Statements
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   9-Jan-2011
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2011, 2025.
--
--   This file is part of Risc2cpp. Risc2cpp is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Risc2cpp.CodeGen ( codeGen )

where

import Risc2cpp.Intermediate
import Risc2cpp.Misc

import Data.Bits ((.&.), shiftL, shiftR)
import Data.Char
import Data.Int
import Data.List
import qualified Data.Map as Map
import Data.Map (Map)
import Data.Maybe
import Data.Word
import Numeric

makeIncludeGuard :: String -> String
makeIncludeGuard = map (\c -> if isAlphaNum c then toUpper c else '_')

-- HPP file
hppContents :: String -> Int -> [String]
hppContents hppFilename numCodeChunks =
    ["// This file was generated by Risc2cpp"
    ,""
    ,"#ifndef " ++ makeIncludeGuard hppFilename
    ,"#define " ++ makeIncludeGuard hppFilename
    ,""
    ,"#include <stdint.h>"
    ,"#include <memory>"
    ,"#include <unordered_map>"
    ,""
    ,""
    ,"class RiscVM"
    ,"{"
    ,"public:"
    ,"    // Constructor"
    ,""
    ,"    // This allocates memory pages for the initial data and bss sections"
    ,"    // of the executable, as well as a single stack page. It also sets all"
    ,"    // registers to zero, except SP which is set to the given value, and PC"
    ,"    // which is set to the entry point address."
    ,"    explicit RiscVM(uint32_t initial_sp = 0xfffefff0);"
    ,""
    ,""
    ,"    // Main execute function"
    ,""
    ,"    // Execute code from current PC until the next ECALL."
    ,"    // Errors (such as illegal memory accesses) will (by default) throw a"
    ,"    // std::runtime_error exception."
    ,"    void execute();"
    ,""
    ,""
    ,"    // Register and PC access"
    ,""
    ,"    // Get register contents as uint32_t."
    ,"    uint32_t getRA() const { return ra; }"
    ,"    uint32_t getSP() const { return sp; }"
    ,"    uint32_t getGP() const { return gp; }"
    ,"    uint32_t getTP() const { return tp; }"
    ,"    uint32_t getT0() const { return t0; }"
    ,"    uint32_t getT1() const { return t1; }"
    ,"    uint32_t getT2() const { return t2; }"
    ,"    uint32_t getS0() const { return s0; }"
    ,"    uint32_t getS1() const { return s1; }"
    ,"    uint32_t getA0() const { return a0; }"
    ,"    uint32_t getA1() const { return a1; }"
    ,"    uint32_t getA2() const { return a2; }"
    ,"    uint32_t getA3() const { return a3; }"
    ,"    uint32_t getA4() const { return a4; }"
    ,"    uint32_t getA5() const { return a5; }"
    ,"    uint32_t getA6() const { return a6; }"
    ,"    uint32_t getA7() const { return a7; }"
    ,"    uint32_t getS2() const { return s2; }"
    ,"    uint32_t getS3() const { return s3; }"
    ,"    uint32_t getS4() const { return s4; }"
    ,"    uint32_t getS5() const { return s5; }"
    ,"    uint32_t getS6() const { return s6; }"
    ,"    uint32_t getS7() const { return s7; }"
    ,"    uint32_t getS8() const { return s8; }"
    ,"    uint32_t getS9() const { return s9; }"
    ,"    uint32_t getS10() const { return s10; }"
    ,"    uint32_t getS11() const { return s11; }"
    ,"    uint32_t getT3() const { return t3; }"
    ,"    uint32_t getT4() const { return t4; }"
    ,"    uint32_t getT5() const { return t5; }"
    ,"    uint32_t getT6() const { return t6; }"
    ,""
    ,"    // Set register contents as uint32_t."
    ,"    void setRA(uint32_t value) { ra = value; }"
    ,"    void setSP(uint32_t value) { sp = value; }"
    ,"    void setGP(uint32_t value) { gp = value; }"
    ,"    void setTP(uint32_t value) { tp = value; }"
    ,"    void setT0(uint32_t value) { t0 = value; }"
    ,"    void setT1(uint32_t value) { t1 = value; }"
    ,"    void setT2(uint32_t value) { t2 = value; }"
    ,"    void setS0(uint32_t value) { s0 = value; }"
    ,"    void setS1(uint32_t value) { s1 = value; }"
    ,"    void setA0(uint32_t value) { a0 = value; }"
    ,"    void setA1(uint32_t value) { a1 = value; }"
    ,"    void setA2(uint32_t value) { a2 = value; }"
    ,"    void setA3(uint32_t value) { a3 = value; }"
    ,"    void setA4(uint32_t value) { a4 = value; }"
    ,"    void setA5(uint32_t value) { a5 = value; }"
    ,"    void setA6(uint32_t value) { a6 = value; }"
    ,"    void setA7(uint32_t value) { a7 = value; }"
    ,"    void setS2(uint32_t value) { s2 = value; }"
    ,"    void setS3(uint32_t value) { s3 = value; }"
    ,"    void setS4(uint32_t value) { s4 = value; }"
    ,"    void setS5(uint32_t value) { s5 = value; }"
    ,"    void setS6(uint32_t value) { s6 = value; }"
    ,"    void setS7(uint32_t value) { s7 = value; }"
    ,"    void setS8(uint32_t value) { s8 = value; }"
    ,"    void setS9(uint32_t value) { s9 = value; }"
    ,"    void setS10(uint32_t value) { s10 = value; }"
    ,"    void setS11(uint32_t value) { s11 = value; }"
    ,"    void setT3(uint32_t value) { t3 = value; }"
    ,"    void setT4(uint32_t value) { t4 = value; }"
    ,"    void setT5(uint32_t value) { t5 = value; }"
    ,"    void setT6(uint32_t value) { t6 = value; }"
    ,""
    ,"    // Get and set PC (program counter)."
    ,"    // Note that the PC can only be set to valid 'branch points' in the"
    ,"    // code; arbitrary PC locations cannot be accepted."
    ,"    uint32_t getPC() const { return pc; }"
    ,"    void setPC(uint32_t value);"
    ,""
    ,""
    ,"    // Memory access"
    ,""
    ,"    // Read 4 bytes (little-endian) from a 4-byte aligned address."
    ,"    uint32_t readWord(uint32_t addr);"
    ,""
    ,"    // Write 4 bytes (little-endian) to a 4-byte aligned address."
    ,"    void writeWord(uint32_t addr, uint32_t value);"
    ,""
    ,"    // Read 2 bytes (little-endian) from a 2-byte aligned address."
    ,"    // Sign-extend the result to uint32_t."
    ,"    uint32_t readHalf(uint32_t addr);"
    ,""
    ,"    // Read 2 bytes (little-endian) from a 2-byte aligned address."
    ,"    // Zero-extend the result to uint32_t."
    ,"    uint32_t readHalfU(uint32_t addr);"
    ,""
    ,"    // Write 2 bytes (little-endian) to a 2-byte aligned address."
    ,"    // Only the bottom 16 bits of 'value' are used."
    ,"    void writeHalf(uint32_t addr, uint32_t value);"
    ,""
    ,"    // Read a single byte from an address."
    ,"    // Sign-extend the result to uint32_t."
    ,"    uint32_t readByte(uint32_t addr);"
    ,""
    ,"    // Read a single byte from an address."
    ,"    // Zero-extend the result to uint32_t."
    ,"    uint32_t readByteU(uint32_t addr);"
    ,""
    ,"    // Write a byte to an address."
    ,"    // Only the bottom 8 bits of 'value' are used."
    ,"    void writeByte(uint32_t addr, uint32_t value);"
    ,""
    ,""
    ,"    // Program break, guard page"
    ,""
    ,"    // Get and set 'program break' location (i.e. first location after"
    ,"    // the end of the current data segment). This can be used to expand"
    ,"    // the data segment or implement a 'brk' or 'sbrk' ecall interface."
    ,"    // Note: The break should not be set below its initial value."
    ,"    // Note: setProgramBreak will allocate or free memory pages as appropriate."
    ,"    uint32_t getProgramBreak() const;"
    ,"    uint32_t getInitialProgramBreak() const;"
    ,"    void setProgramBreak(uint32_t new_value);"
    ,""
    ,"    // Get and set stack guard page address."
    ,"    // (These functions are used by the default implementation of handleInvalidAddress.)"
    ,"    uint32_t getGuardPageAddress() const { return guard_page_num << 16; }"
    ,"    void setGuardPageAddress(uint32_t addr) { guard_page_num = (addr >> 16); }"
    ,""
    ,""
    ,"    // Manual memory management"
    ,""
    ,"    // Functions to allocate and deallocate individual 64 KB pages,"
    ,"    // or to get direct access to the page memory."
    ,"    // Note: 'addr' is rounded down to a multiple of the page size."
    ,"    void allocatePage(uint32_t addr);"
    ,"    void deallocatePage(uint32_t addr);"
    ,"    bool isPageAllocated(uint32_t addr) const;"
    ,"    void* getPageAddress(uint32_t addr) const;"
    ,""
    ,"    // This function can be overridden to change the behaviour when the"
    ,"    // VM tries to access an invalid address. It should either call"
    ,"    // allocatePage to make the address valid, or throw an exception."
    ,"    // (The default behaviour is to allocate if the address is in"
    ,"    // the stack guard area, or throw otherwise.)"
    ,"    virtual void handleInvalidAddress(uint32_t addr);"
    ,""
    ,""
    ,"    // Useful constants"
    ,""
       -- Note: if changing BYTES_PER_PAGE you would also need to modify
       -- a lot of other things in the code, because (unfortunately) we have
       -- various hard coded expressions that are functions of the page size,
       -- like (addr >> 16) or (addr & 0xffff), in multiple places.
    ,"    static constexpr int NUM_PAGES = 65536;"
    ,"    static constexpr int BYTES_PER_PAGE = 65536;"
    ,"    static constexpr int WORDS_PER_PAGE = 16384;"
    ,""
    ,""
    ,"private:"
    ,"    void initCaseTable();"
    ,"    void initMem();"
    ,"    int getBlockNumber(uint32_t addr) const;"
    ,""
    ]
    ++ map (\i -> "    int exec" ++ show i ++ "(int bx);") [0..numCodeChunks - 1]
    ++[""
    ,"    uint32_t ra, sp, gp, tp, t0, t1, t2;"
    ,"    uint32_t s0, s1, a0, a1, a2, a3, a4, a5, a6, a7;"
    ,"    uint32_t s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;"
    ,"    uint32_t t3, t4, t5, t6;"
    ,"    uint32_t pc;"
    ,"    int block_number;"
    ,"    uint32_t program_break;"
    ,"    uint32_t initial_program_break;"
    ,"    uint32_t guard_page_num;"
    ,"    std::unique_ptr<uint32_t[]> mem[NUM_PAGES];"
    ,"    std::unordered_map<uint32_t, int> case_table;"
    ,"};"
    ,""
    ,"#endif"
    ,""
    ]


-- Prologue: placed at beginning of the generated .cpp file
cppPrologue :: String -> Word32 -> Word32 -> Int -> [String]
cppPrologue hppFilename programBreak startAddr startBlock =
    ["// This file was generated by Risc2cpp"
    ,""
    ,"#include \"" ++ hppFilename ++ "\""
    ,""
    ,"#include <stdexcept>"
    ,"#include <cstring>"
    ,""
    ,""
    ,"// CONSTRUCTOR"
    ,""
    ,"RiscVM::RiscVM(uint32_t initial_sp)"
    ,"{"
    ,"    // Initialize all registers to zero"
    ,"    ra = sp = gp = tp = t0 = t1 = t2 = 0;"
    ,"    s0 = s1 = a0 = a1 = a2 = a3 = a4 = a5 = a6 = a7 = 0;"
    ,"    s2 = s3 = s4 = s5 = s6 = s7 = s8 = s9 = s10 = s11 = 0;"
    ,"    t3 = t4 = t5 = t6 = 0;"
    ,""
    ,"    // Set initial PC"
    ,"    pc = " ++ toHex startAddr ++ ";"
    ,"    block_number = " ++ show startBlock ++ ";"
    ,""
    ,"    // Set initial program break"
    ,"    program_break = initial_program_break = " ++ toHex programBreak ++ ";"
    ,""
    ,"    // Initialize the stack. We allocate one stack page, containing (at least)"
    ,"    // the address one byte below the given SP value."
    ,"    sp = initial_sp;"
    ,"    allocatePage(sp - 1);"
    ,"    guard_page_num = ((sp - 1) >> 16) - 1;   // one below the initial stack page"
    ,""
    ,"    // Initialize the data and BSS pages"
    ,"    initMem();"
    ,""
    ,"    // Initialize case table"
    ,"    initCaseTable();"
    ,"}"
    ,""
    ,""
    ,"// SET PC FUNCTION"
    ,""
    ,"void RiscVM::setPC(uint32_t value)"
    ,"{"
    ,"    pc = value;"
    ,"    block_number = getBlockNumber(value);"
    ,"}"
    ,""
    ,"int RiscVM::getBlockNumber(uint32_t addr) const"
    ,"{"
    ,"    // Get basic block number corresponding to a code address"
    ,"    auto find = case_table.find(addr);"
    ,"    if (find != case_table.end()) {"
    ,"        return find->second;"
    ,"    } else {"
    ,"        throw std::runtime_error(\"Invalid code address\");"
    ,"    }"
    ,"}"
    ,""
    ,""
    ,"// MEMORY ACCESS FUNCTIONS"
    ,""
    ,"uint32_t RiscVM::readWord(uint32_t addr)"
    ,"{"
    ,"    uint32_t page_num = addr >> 16;"
    ,"    uint32_t index_within_page = (addr & 0xffff) >> 2;"
    ,"    if (!mem[page_num]) {"
    ,"        handleInvalidAddress(addr);"
    ,"    }"
    ,"    return mem[page_num][index_within_page];"
    ,"}"
    ,""
    ,"void RiscVM::writeWord(uint32_t addr, uint32_t value)"
    ,"{"
    ,"    uint32_t page_num = addr >> 16;"
    ,"    uint32_t index_within_page = (addr & 0xffff) >> 2;"
    ,"    if (!mem[page_num]) {"
    ,"        handleInvalidAddress(addr);"
    ,"    }"
    ,"    mem[page_num][index_within_page] = value;"
    ,"}"
    ,""
    ,"uint32_t RiscVM::readHalf(uint32_t addr)"
    ,"{"
    ,"    uint32_t word = readWord(addr);"
    ,"    word >>= ((addr & 2) << 3);"
    ,"    return (int16_t) word;"
    ,"}"
    ,""
    ,"uint32_t RiscVM::readHalfU(uint32_t addr)"
    ,"{"
    ,"    uint32_t word = readWord(addr);"
    ,"    word >>= ((addr & 2) << 3);"
    ,"    return (uint16_t) word;"
    ,"}"
    ,""
    ,"void RiscVM::writeHalf(uint32_t addr, uint32_t value)"
    ,"{"
    ,"    uint32_t page_num = addr >> 16;"
    ,"    uint32_t index_within_page = (addr & 0xffff) >> 2;"
    ,"    if (!mem[page_num]) {"
    ,"        handleInvalidAddress(addr);"
    ,"    }"
    ,"    uint32_t word = mem[page_num][index_within_page];"
    ,"    uint32_t shift = (addr & 2) << 3;"
    ,"    uint32_t mask = 0xffff << shift;"
    ,"    word = (word & ~mask) | ((value << shift) & mask);"
    ,"    mem[page_num][index_within_page] = word;"
    ,"}"
    ,""
    ,"uint32_t RiscVM::readByte(uint32_t addr)"
    ,"{"
    ,"    uint32_t word = readWord(addr);"
    ,"    word >>= ((addr & 3) << 3);"
    ,"    return (int8_t) word;"
    ,"}"
    ,""
    ,"uint32_t RiscVM::readByteU(uint32_t addr)"
    ,"{"
    ,"    uint32_t word = readWord(addr);"
    ,"    word >>= ((addr & 3) << 3);"
    ,"    return (uint8_t) word;"
    ,"}"
    ,""
    ,"void RiscVM::writeByte(uint32_t addr, uint32_t value)"
    ,"{"
    ,"    uint32_t page_num = addr >> 16;"
    ,"    uint32_t index_within_page = (addr & 0xffff) >> 2;"
    ,"    if (!mem[page_num]) {"
    ,"        handleInvalidAddress(addr);"
    ,"    }"
    ,"    uint32_t word = mem[page_num][index_within_page];"
    ,"    uint32_t shift = (addr & 3) << 3;"
    ,"    uint32_t mask = 0xff << shift;"
    ,"    word = (word & ~mask) | ((value << shift) & mask);"
    ,"    mem[page_num][index_within_page] = word;"
    ,"}"
    ,""
    ,""
    ,"// PROGRAM BREAK"
    ,""
    ,"uint32_t RiscVM::getProgramBreak() const"
    ,"{"
    ,"    return program_break;"
    ,"}"
    ,""
    ,"uint32_t RiscVM::getInitialProgramBreak() const"
    ,"{"
    ,"    return initial_program_break;"
    ,"}"
    ,""
    ,"void RiscVM::setProgramBreak(uint32_t new_program_break)"
    ,"{"
    ,"    if (new_program_break < initial_program_break) {"
    ,"        throw std::runtime_error(\"Program break set too low\");"
    ,"    }"
    ,""
    ,"    uint32_t current_page = (program_break - 1) >> 16;"
    ,"    uint32_t new_page = (new_program_break - 1) >> 16;"
    ,"    while (new_page < current_page) {"
    ,"        // Free no-longer-used pages"
    ,"        deallocatePage(current_page << 16);"
    ,"        --current_page;"
    ,"    }"
    ,"    while (new_page > current_page) {"
    ,"        // Allocate new pages"
    ,"        ++current_page;"
    ,"        allocatePage(current_page << 16);"
    ,"    }"
    ,"    program_break = new_program_break;"
    ,"}"
    ,""
    ,""
    ,"// MEMORY MANAGEMENT"
    ,""
    ,"void RiscVM::allocatePage(uint32_t addr)"
    ,"{"
    ,"    uint32_t page_num = addr >> 16;"
    ,"    if (!mem[page_num]) {"
    ,"        mem[page_num] = std::make_unique<uint32_t[]>(WORDS_PER_PAGE);"
    ,"    }"
    ,"}"
    ,""
    ,"void RiscVM::deallocatePage(uint32_t addr)"
    ,"{"
    ,"    mem[addr >> 16].reset();"
    ,"}"
    ,""
    ,"bool RiscVM::isPageAllocated(uint32_t addr) const"
    ,"{"
    ,"    return !!(mem[addr >> 16]);"
    ,"}"
    ,""
    ,"void* RiscVM::getPageAddress(uint32_t addr) const"
    ,"{"
    ,"    return mem[addr >> 16].get();"
    ,"}"
    ,""
    ,"void RiscVM::handleInvalidAddress(uint32_t addr)"
    ,"{"
    ,"    // This implements the stack guard page mechanism."
    ,"    if ((addr & 0xffff0000) == getGuardPageAddress()) {"
    ,"        allocatePage(addr);"
    ,"        setGuardPageAddress(getGuardPageAddress() - BYTES_PER_PAGE);"
    ,"        if (isPageAllocated(getGuardPageAddress())) {"
    ,"            // The stack is about to run into some other allocated page;"
    ,"            // that would be bad!"
    ,"            throw std::runtime_error(\"Stack overflow\");"
    ,"        }"
    ,"    } else {"
    ,"        throw std::runtime_error(\"Illegal memory access\");"
    ,"    }"
    ,"}"
    ,""
    ,""
    ]


-- Code for initMem function

initMem :: [(Word32, [Word32])] -> [String]
initMem dataChunks = 
    let header = ["// INITIAL MEMORY IMAGE"
                 ,""
                 ,"namespace"
                 ,"{"
                 ]
        funcHeader = ["}"
                     ,""
                     ,"void RiscVM::initMem()"
                     ,"{"
                     ]
        funcFooter = ["}"
                     ,""
                     ,""
                     ]
    in header
       ++ concatMap makeDataImage dataChunks
       ++ funcHeader
       ++ concatMap makeDataInit dataChunks
       ++ funcFooter

makeDataImage :: (Word32, [Word32]) -> [String]
makeDataImage (addr, words)
  | all (==0) words = []
  | otherwise =
      ["    const uint32_t mem_image_" ++ show pageNum ++ "[" ++ show (length words) ++ "] = {"]
      ++ map arrayInitializer (blocks words)
      ++ ["    };"]
  where blocks [] = []
        blocks xs = let (a,b) = splitAt 16 xs in a : blocks b
        pageNum = addr `shiftR` 16

arrayInitializer :: [Word32] -> String
arrayInitializer y = "        " ++ concatMap (\x -> show x ++ ", ") y

makeDataInit :: (Word32, [Word32]) -> [String]
makeDataInit (addr, words) =
    ["    mem[" ++ show pageNum ++ "] = std::make_unique<uint32_t[]>(" ++ show (length words) ++ ");"]
    ++ (if any (/=0) words then
          ["    memcpy(mem[" ++ show pageNum ++ "].get(), mem_image_" ++ show pageNum ++ ", " ++ show (length words * 4) ++ ");"]
        else [])
    where pageNum = addr `shiftR` 16


-- Code Generation

memFunction :: MemOp -> String
memFunction MemByte = "Byte"
memFunction MemByteU = "ByteU"
memFunction MemHalf = "Half"
memFunction MemHalfU = "HalfU"
memFunction MemWord = "Word"

-- Simple binary operators (that can be done at uint32_t type)
genBinOp :: BinOp -> String
genBinOp Add = "+"
genBinOp And = "&"
genBinOp Mult = "*"
genBinOp QuotU = "/"
genBinOp RemU = "%"
genBinOp Or = "|"
genBinOp LogicalShiftLeft = "<<"
genBinOp LogicalShiftRight = ">>"
genBinOp Sub = "-"
genBinOp Xor = "^"

-- Simple comparison operators (that can be done at uint32_t type)
genCondOp :: CondOp -> String
genCondOp Equal = "=="
genCondOp NotEqual = "!="
genCondOp GtrThanU = ">"
genCondOp LessThanU = "<"
genCondOp GtrEqualU = ">="
genCondOp LessEqualU = "<="

-- Generate an expression of type int64_t (sign-extending the base 32-bit value)
genExprInt64 :: Expr -> String
genExprInt64 (LitExpr i) = "INT64_C(" ++ show i ++ ")"
genExprInt64 e = "((int64_t)(int32_t)" ++ genExprUint32 e ++ ")"

-- Generate an expression of type uint64_t (zero-extending the base 32-bit value)
genExprUint64 :: Expr -> String
genExprUint64 (LitExpr i) = "UINT64_C(" ++ show ((fromIntegral i) :: Word32) ++ ")"
genExprUint64 e = "((uint64_t)" ++ genExprUint32 e ++ ")"

-- Generate an expression of type int32_t
genExprInt32 :: Expr -> String
genExprInt32 (LitExpr i) = "INT32_C(" ++ show i ++ ")"
genExprInt32 e = "((int32_t)" ++ genExprUint32 e ++ ")"

-- Generate an expression of type uint32_t
genExprUint32 :: Expr -> String
genExprUint32 (LitExpr i) = "UINT32_C(" ++ show i ++ ")"
genExprUint32 (VarExpr v) = v
genExprUint32 (UnExpr Negate x) = "(-" ++ genExprUint32 x ++ ")"
genExprUint32 (UnExpr Not x) = "(~" ++ genExprUint32 x ++ ")"
genExprUint32 (BinExpr MultHi lhs rhs) = "( (uint32_t)( (" ++ genExprInt64 lhs ++ " * " ++ genExprInt64 rhs ++ ") >> 32) )"
genExprUint32 (BinExpr MultHiU lhs rhs) = "( (uint32_t)( (" ++ genExprUint64 lhs ++ " * " ++ genExprUint64 rhs ++ ") >> 32) )"
genExprUint32 (BinExpr MultHiSU lhs rhs) = "( (uint32_t)( (((uint64_t)" ++ genExprInt64 lhs ++ ") * " ++ genExprUint64 rhs ++ ") >> 32) )"
genExprUint32 (BinExpr Quot lhs rhs) =
    -- Note: strictly speaking, RISC-V defines rules for division by
    -- zero or signed division overflow, but we will ignore those and
    -- just crash (or create undefined behaviour) in those cases!
    "( (uint32_t)( " ++ genExprInt32 lhs ++ " / " ++ genExprInt32 rhs ++ ") )"
genExprUint32 (BinExpr Rem lhs rhs) = "( (uint32_t)( " ++ genExprInt32 lhs ++ " % " ++ genExprInt32 rhs ++ ") )"
genExprUint32 (BinExpr ArithShiftRight lhs rhs) = "( (uint32_t)( " ++ genExprInt32 lhs ++ " >> " ++ genExprInt32 rhs ++ " ))"
genExprUint32 (BinExpr SetIfLess lhs rhs) = "((uint32_t)(" ++ genExprInt32 lhs ++ " < " ++ genExprInt32 rhs ++ " ? 1 : 0))"
genExprUint32 (BinExpr SetIfLessU lhs rhs) = "((uint32_t)(" ++ genExprUint32 lhs ++ " < " ++ genExprUint32 rhs ++ " ? 1 : 0))"
genExprUint32 (BinExpr op lhs rhs) = "(" ++ genExprUint32 lhs ++ " " ++ genBinOp op ++ " " ++ genExprUint32 rhs ++ ")"
genExprUint32 (LoadMemExpr op addr) = "read" ++ memFunction op ++ "(" ++ genExprUint32 addr ++ ")"
genExprUint32 (LoadRegExpr reg) = reg

genCondExpr :: CondExpr -> String
genCondExpr (BinCond GtrThan lhs rhs) = genExprInt32 lhs ++ " > " ++ genExprInt32 rhs
genCondExpr (BinCond LessThan lhs rhs) = genExprInt32 lhs ++ " < " ++ genExprInt32 rhs
genCondExpr (BinCond GtrEqual lhs rhs) = genExprInt32 lhs ++ " >= " ++ genExprInt32 rhs
genCondExpr (BinCond LessEqual lhs rhs) = genExprInt32 lhs ++ " <= " ++ genExprInt32 rhs
genCondExpr (BinCond op lhs rhs) = genExprUint32 lhs ++ " " ++ genCondOp op ++ " " ++ genExprUint32 rhs
genCondExpr (LitCond True) = "true"
genCondExpr (LitCond False) = "false"

-- generate C++ code for a single statement.
-- note: generated code is not indented.
genStmt :: Map Addr Int -> Int -> Statement -> String
genStmt _ _ (Let varName rhs) =
   varName ++ " = " ++ genExprUint32 rhs ++ ";"
genStmt _ _ (StoreMem op addr value) =
   "write" ++ memFunction op ++ "(" ++ genExprUint32 addr ++ ", " ++ genExprUint32 value ++ ");"
genStmt _ _ (StoreReg regName rhs) =
   regName ++ " = " ++ genExprUint32 rhs ++ ";"
genStmt blockNos firstBlockNum (Jump cond addrTrue addrFalse) = 
    case cond of
      LitCond True -> genJump blockNos firstBlockNum addrTrue
      LitCond False -> genJump blockNos firstBlockNum addrFalse
      _ -> "if (" ++ genCondExpr cond ++ ") { "
           ++ genJump blockNos firstBlockNum addrTrue ++ " } else { "
           ++ genJump blockNos firstBlockNum addrFalse ++ " }"
genStmt _ _ (IndirectJump addr) = 
    "return getBlockNumber(" ++ genExprUint32 addr ++ ");"
genStmt blockNos _ (Syscall newPC) = "pc = " ++ toHex newPC ++ "; block_number = " ++ show (blockNos Map.! newPC) ++ "; return -1;"
genStmt _ _ Break = "throw std::runtime_error(\"EBREAK instruction executed\");"

genJump :: Map Addr Int -> Int -> Addr -> String
genJump blockNos firstBlockNum addr = 
    let label = case Map.lookup addr blockNos of
                  Just x -> x
                  Nothing -> error $ "Missing case label for address: " ++ toHex addr
    in if label >= firstBlockNum && label < firstBlockNum + numBlocksPerMethod then
           "goto case_" ++ show (label .&. (numBlocksPerMethod - 1)) ++ ";"
       else "return " ++ show label ++ ";"

-- add indentation
indent :: Int -> String -> String
indent n s = (take n (repeat ' ')) ++ s

-- generate 'full' code for a basic block
-- including case label & indentation
genBasicBlock :: Map Addr Int -> Int -> (Addr, [Statement]) -> [String]
genBasicBlock allBlockNos firstBlockNum (addr, stmts) = 
    let innerCaseNum = (allBlockNos Map.! addr) .&. (numBlocksPerMethod - 1)
        code = map (genStmt allBlockNos firstBlockNum) stmts   :: [String]
        caseLabel = "case " ++ show innerCaseNum ++ ": case_" ++ show innerCaseNum ++ ":    // " ++ toHex addr
    in [caseLabel] ++ map (indent 4) code ++ [""]


-- Compute the map of addr -> block number.
makeBlockNumsMap :: Map Addr [Statement] -> Map Addr Int
makeBlockNumsMap blocks =
    let codeBlocks = zip (Map.keys blocks) [0..]
    in Map.fromAscList codeBlocks


-- Parameters for trampoline
trampolineShift = 8

numBlocksPerMethod :: Int
numBlocksPerMethod = 1 `shiftL` trampolineShift


-- Code for 'run' method (the trampoline)
makeTrampoline :: Int -> [String]
makeTrampoline numCodeChunks =
    ["// MAIN EXECUTE ROUTINE"
    ,""
    ,"void RiscVM::execute()"
    ,"{"
    ,"    int bb = block_number;"
    ,""
    ,"    while (bb >= 0)"
    ,"    {"
    ,"        int bx = bb & " ++ show (numBlocksPerMethod - 1) ++ ";"
    ,"        switch (bb >> " ++ show trampolineShift ++ ")"
    ,"        {"]
    ++ map makeTrampolineCase [0 .. numCodeChunks - 1]
    ++ ["        default:"
       ,"            throw std::runtime_error(\"Block number incorrect\");"
       ,"        }"
       ,"    }"
       ,"}"
       ,""]

makeTrampolineCase :: Int -> String
makeTrampolineCase n = "            case " ++ show n ++ ": bb = exec" ++ show n ++ "(bx); break;"

-- Code for the individual 'exec' methods
makeExecMethod :: Int -> [(Addr, [Statement])] -> Map Addr Int -> [String]
makeExecMethod firstBlock blocks blockNumMap = 
    ["int RiscVM::exec" ++ show outerBlockNum ++ "(int bx)"
    ,"{"]
    ++ declareLocals (concatMap snd blocks)
    ++ ["    switch (bx)"
       ,"    {"]
       ++ codeStrings
       ++ ["    }"
          ,"    throw std::runtime_error(\"Invalid block number\");"
          ,"}"
          ,""]
   where
     outerBlockNum = firstBlock `shiftR` trampolineShift
     codeStrings' = concatMap (genBasicBlock blockNumMap firstBlock) blocks :: [String]
     codeStrings = map (indent 8) codeStrings'


declareLocals :: [Statement] -> [String]
declareLocals stmts = 
    let exprs = concatMap findExprsInStmt stmts
        vars = uniq $ sort $ concatMap findVarsInExpr exprs
    in map (\x -> "    uint32_t " ++ x ++ ";") vars


initCaseTable :: Map Addr Int -> [Addr] -> [String]
initCaseTable addrToCase addrs = ["// CASE TABLE"
                                 ,""
                                 ,"void RiscVM::initCaseTable()"
                                 ,"{"]
                                 ++ map (\a -> "    case_table[" ++ (toHex a) ++ "] = " ++ show (addrToCase Map.! a) ++ ";") addrs
                                 ++ ["}"
                                    ,""]

codeGen :: String -> Map Addr [Statement] -> [Addr] -> [(Word32, [Word32])] -> Word32 -> Word32 -> ([String], [String])
codeGen hppFilename blocks indirectJumpTargets dataChunks entryPoint programBreak =
    let blockMap = makeBlockNumsMap blocks
        codeChunks = groupsOf numBlocksPerMethod (Map.toList blocks)
    in
      ( hppContents hppFilename (length codeChunks)
      , cppPrologue hppFilename programBreak entryPoint (blockMap Map.! entryPoint)
      ++ makeTrampoline (length codeChunks)
      ++ concatMap (\(x,n) -> makeExecMethod n x blockMap) (zip codeChunks [0, numBlocksPerMethod ..])
      ++ initCaseTable blockMap (uniq $ sort indirectJumpTargets)
      ++ initMem dataChunks
      )

groupsOf :: Int -> [a] -> [[a]]
groupsOf n [] = []
groupsOf n xs = let (grp,rest) = splitAt n xs
                in grp : groupsOf n rest
