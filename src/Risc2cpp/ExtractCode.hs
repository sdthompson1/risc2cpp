-- MODULE:
--   Risc2cpp.ExtractCode
--
-- PURPOSE:
--   Extracts code and data chunks, and a list of possible indirect
--   jump targets, from an ELF binary. Also disassembles the code.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   9-Jun-2011
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2011, 2025.
--
--   This file is part of Risc2cpp. Risc2cpp is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Risc2cpp.ExtractCode

    ( extractCode
    )

where

import Risc2cpp.RiscV
import Risc2cpp.Misc

import Data.Bits
import qualified Data.ByteString as B
import Data.Char (ord)
import Data.Elf
import Data.Int
import Data.List
import Data.Maybe
import Data.Ord
import qualified Data.Set as Set
import Data.Set (Set)
import Data.Word

-- return values:
--  1) list of possible *indirect* jump targets (inferred from symbol locations) -- does NOT include "jal" return addrs (yet)
--  2) list of code chunks (list of addr + instruction pairs)
--  3) list of data chunks (each having base addr + list of Word32s). These are all of size 64K and 64K-aligned.
--  4) program break (highest actually used data address, plus one).
extractCode :: Elf -> ([Addr], [(Addr, Insn)], [(Addr, [Word32])], Addr )
extractCode elf =
    let allSections = sortBy (comparing elfSectionAddr) (elfSections elf)
        dataSections = filter isDataSection allSections
        codeSections = filter isCodeSection allSections
        codeChunks = makeCodeChunks codeSections
        dataChunks = makeDataChunks dataSections
        programBreak = calculateProgramBreak dataSections
        indirectJumpTargets = findIndirectJumpTargets elf
    in (indirectJumpTargets, codeChunks, dataChunks, programBreak)


-- Checks whether a section should be included as "data"
isDataSection :: ElfSection -> Bool
isDataSection section = 
    let flags = elfSectionFlags section in
      (SHF_ALLOC `elem` flags) && (not (SHF_EXECINSTR `elem` flags))

-- Checks whether a section should be included as "code"
isCodeSection :: ElfSection -> Bool
isCodeSection section = 
    let flags = elfSectionFlags section in
      (SHF_ALLOC `elem` flags) && (SHF_EXECINSTR `elem` flags)

-- Checks whether a section is going to be included in the final executable
isIncludedSection :: ElfSection -> Bool
isIncludedSection x = isDataSection x || isCodeSection x


makeDataChunks :: [ElfSection] -> [(Addr, [Word32])]
makeDataChunks sections =
    let inputChunks = map sectionToChunk sections
        paddedChunks = map ((padChunkEnd 16384) . (padChunkStart 16384)) inputChunks
        splitUpChunks = concatMap (splitChunk 16384) paddedChunks
        sorted = sortBy (comparing fst) splitUpChunks
    in mergeChunks sorted

-- Turn a section into a base address, list of Word32s, and length
sectionToChunk :: ElfSection -> (Addr, [Word32], Word32)
sectionToChunk section = ( fromIntegral (elfSectionAddr section)
                         , getWords section
                         , (fromIntegral (elfSectionSize section)) `quot` 4 )

-- Pad a chunk at the beginning to be aligned to chunkNumBytes
padChunkStart :: Word32 -> (Addr,[Word32],Word32) -> (Addr,[Word32],Word32)
padChunkStart chunkSizeWords (addr, words, len) =
    let paddingWords = (addr`quot`4) `rem` chunkSizeWords
    in ( addr - paddingWords * 4
       , genericTake paddingWords (repeat 0) ++ words
       , len + paddingWords )

-- Pad a chunk at the end to be a multiple of chunkNumBytes
padChunkEnd :: Word32 -> (Addr,[Word32],Word32) -> (Addr,[Word32],Word32)
padChunkEnd chunkSizeWords (addr, words, len) = 
    let paddingWords' = chunkSizeWords - (len `rem` chunkSizeWords)
        paddingWords = if paddingWords' == chunkSizeWords then 0 else paddingWords'
    in ( addr
       , words ++ genericTake paddingWords (repeat 0)
       , len + paddingWords )

-- Split a chunk (assumed padded at both ends) into multiple chunks of size exactly chunkSizeWords
splitChunk :: Word32 -> (Addr,[Word32],Word32) -> [(Addr,[Word32])]
splitChunk chunkSizeWords (addr, words, len)
    | len == chunkSizeWords
        = [(addr, words)]
    | len > chunkSizeWords
        = let (before, after) = genericSplitAt chunkSizeWords words
          in (addr, before) : splitChunk chunkSizeWords (addr + chunkSizeWords*4, after, len - chunkSizeWords)
    | otherwise
        = error $ "splitChunk: chunk size was not a multiple of " ++ show (chunkSizeWords * 4)

-- Merge adjacent chunks if they have the same start address.
mergeChunks :: [(Addr,[Word32])] -> [(Addr,[Word32])]
mergeChunks [] = []
mergeChunks [x] = [x]
mergeChunks (x:y:rest) | fst x /= fst y = x : mergeChunks (y:rest)
                       | otherwise      = mergeChunks ((mergeChunk x y) : rest)

-- The merge is done by taking the 'max' word from each chunk.
-- (This gets rid of any zero padding that might have made the chunks overlap.)
mergeChunk :: (Addr,[Word32]) -> (Addr,[Word32]) -> (Addr,[Word32])
mergeChunk (addr,w1) (_,w2) = (addr, map (\(a,b)->max a b) (zip w1 w2))


calculateProgramBreak :: [ElfSection] -> Addr
calculateProgramBreak [] = 0
calculateProgramBreak sections =
    fromIntegral $ maximum $ map (\sec -> elfSectionAddr sec + elfSectionSize sec) sections


makeCodeChunks :: [ElfSection] -> [(Addr, Insn)]
makeCodeChunks = concatMap makeCodeChunk

makeCodeChunk :: ElfSection -> [(Addr, Insn)]
makeCodeChunk sec = 
    let startAddr = fromIntegral (elfSectionAddr sec)
        addrList = [startAddr, startAddr+4 ..]
        insns = map disassemble (getWords sec)
    in zip addrList insns

-- Read all the data words from a chunk. 
-- Expands out SHT_NOBITS sections into a string of zeros. (In practice this means BSS sections.)
getWords :: ElfSection -> [Word32]
getWords section = case elfSectionType section of
                     SHT_NOBITS -> genericTake ((elfSectionSize section + 3) `div` 4) (repeat 0)
                     _ -> toWordList (elfSectionData section)

toWordList :: B.ByteString -> [Word32]
toWordList str =
    -- read groups of four bytes, convert to Word32 using little-endian encoding
    let bytes = B.unpack str
        fours = getFours bytes
    in map (\(a,b,c,d) -> (((fromIntegral d) `shiftL` 24) + ((fromIntegral c) `shiftL` 16) + ((fromIntegral b) `shiftL` 8) + (fromIntegral a))) fours
        where getFours [] = []
              getFours (a:b:c:d:rest) = (a,b,c,d) : getFours rest
              getFours [a,b,c] = [(a,b,c,0)]  -- pad with zeros if needed
              getFours [a,b] = [(a,b,0,0)]
              getFours [a] = [(a,0,0,0)]


findIndirectJumpTargets :: Elf -> [Addr]
findIndirectJumpTargets elf =
    let syms = concat $ parseSymbolTables elf
    in mapMaybe getJumpTargetFromSymbol syms

getJumpTargetFromSymbol :: ElfSymbolTableEntry -> Maybe Addr
getJumpTargetFromSymbol ste =
    -- Assume that any symbol pointing to a valid address within a code section
    -- could potentially be an indirect jump target.
    case steEnclosingSection ste of
      Just sec | isCodeSection sec && validCodeAddress sec (steValue ste) ->
        Just (fromIntegral (steValue ste))
      _ ->
        Nothing

validCodeAddress :: ElfSection -> Word64 -> Bool
validCodeAddress sec addr =
    addr >= (elfSectionAddr sec)
    && addr < (elfSectionAddr sec + elfSectionSize sec)
    && ((addr .&. 3) == 0)
