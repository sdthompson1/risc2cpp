-- MODULE:
--   Risc2cpp.Intermediate
--
-- PURPOSE:
--   Intermediate language, consisting of Statements and Exprs.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   26-Dec-2010
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011, 2025.
--
--   This file is part of Risc2cpp. Risc2cpp is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Risc2cpp.Intermediate
    ( VarName
    , RegName
    , Addr
    , BinOp(..)
    , applyBinOp
    , isCommutative
    , isAssociative
    , UnOp(..)
    , applyUnOp
    , Expr(..)
    , MemOp(..)
    , Statement(..)
    , CondOp(..)
    , CondExpr(..)
    , applyCond
    , mapOverExprs       -- apply func to all Exprs in a Statement
    , mapOverExprsC      -- apply func to all Exprs in a CondExpr
    , mapOverCondExprs   -- apply func to all CondExprs in a Statement
    , findExprsInStmt
    , findExprsInCondExpr
    , findVarsInExpr
    )

where

import Data.Bits (Bits, (.&.), (.|.), xor, complement, shiftL, shiftR)
import Data.Int
import Data.Word

type VarName = String
type RegName = String

type Addr = Word32

-- Binary operators
-- At the moment, only 32-bit integer operators are supported.
data BinOp = Add
           | Sub
           | Mult
           | MultHi
           | MultHiU
           | MultHiSU
           | Quot
           | QuotU
           | Rem
           | RemU
           | And
           | Or
           | Xor
           | LogicalShiftLeft
           | LogicalShiftRight
           | ArithShiftRight
           | SetIfLess
           | SetIfLessU
     deriving (Show, Eq)

-- Useful functions for working with operators
applyBinOp :: BinOp -> Int32 -> Int32 -> Int32
applyBinOp Add = (+)
applyBinOp Sub = (-)
applyBinOp Mult = (*)
applyBinOp MultHi = multFuncHi True True
applyBinOp MultHiU = multFuncHi False False
applyBinOp MultHiSU = multFuncHi True False
applyBinOp Quot = quot
applyBinOp QuotU = unsigned quot
applyBinOp Rem = rem
applyBinOp RemU = unsigned rem
applyBinOp And = (.&.)
applyBinOp Or = (.|.)
applyBinOp Xor = xor
applyBinOp LogicalShiftLeft = shiftLeftFunc
applyBinOp LogicalShiftRight = unsigned shiftRightFunc
applyBinOp ArithShiftRight = shiftRightFunc
applyBinOp SetIfLess = setIfLessFunc
applyBinOp SetIfLessU = unsigned setIfLessFunc

isCommutative :: BinOp -> Bool
isCommutative Add = True
isCommutative Sub = False
isCommutative Mult = True
isCommutative MultHi = True
isCommutative MultHiU = True
isCommutative MultHiSU = False
isCommutative Quot = False
isCommutative QuotU = False
isCommutative Rem = False
isCommutative RemU = False
isCommutative And = True
isCommutative Or = True
isCommutative Xor = True
isCommutative LogicalShiftLeft = False
isCommutative LogicalShiftRight = False
isCommutative ArithShiftRight = False
isCommutative SetIfLess = False
isCommutative SetIfLessU = False

isAssociative :: BinOp -> Bool
isAssociative Add = True
isAssociative Sub = False
isAssociative Mult = True
isAssociative MultHi = False
isAssociative MultHiU = False
isAssociative MultHiSU = False
isAssociative Quot = False
isAssociative QuotU = False
isAssociative Rem = False
isAssociative RemU = False
isAssociative And = True
isAssociative Or = True
isAssociative Xor = True
isAssociative LogicalShiftLeft = False
isAssociative LogicalShiftRight = False
isAssociative ArithShiftRight = False
isAssociative SetIfLess = False
isAssociative SetIfLessU = False

-- Helper functions for the above
unsigned :: (Word32 -> Word32 -> Word32) -> Int32 -> Int32 -> Int32
unsigned f x y = fromIntegral $ f (fromIntegral x :: Word32) (fromIntegral y :: Word32)

setIfLessFunc :: Integral a => a -> a -> a
setIfLessFunc x y = if x < y then 1 else 0

shiftLeftFunc :: (Bits a, Integral a) => a -> a -> a
shiftLeftFunc x y = x `shiftL` (fromIntegral y)

shiftRightFunc :: (Bits a, Integral a) => a -> a -> a
shiftRightFunc x y = x `shiftR` (fromIntegral y)

multFuncHi :: Bool -> Bool -> Int32 -> Int32 -> Int32
multFuncHi lhsIsSigned rhsIsSigned lhs rhs =
    -- Extend both lhs and rhs to 64-bit (with appropriate signedness)
    let extend64 :: Bool -> Int32 -> Int64
        extend64 True i = fromIntegral i
        extend64 False i = fromIntegral (fromIntegral i :: Word32)

        lhs64 :: Int64
        lhs64 = extend64 lhsIsSigned lhs

        rhs64 :: Int64
        rhs64 = extend64 rhsIsSigned rhs

    -- Now compute the full 64-bit product (this is 64 x 64 -> 64 so it
    -- doesn't matter whether we use signed or unsigned multiply)
        fullProduct :: Int64
        fullProduct = lhs64 * rhs64

    -- Finally, take the top 32 bits of the result
    -- (Arith vs logical right shift doesn't matter here, since we
    -- only want the bottom 32 bits of the shifted result anyway)
    in fromIntegral (fullProduct `shiftR` 32)

-- Unary operators
data UnOp = Negate
          | Not
            deriving (Show, Eq)

applyUnOp :: UnOp -> Int32 -> Int32
applyUnOp Negate = \x -> (-x)
applyUnOp Not = complement


-- Expressions
-- NOTE: Expressions never have 'write' side effects, although they may read memory and/or registers.
data Expr = LitExpr Int32
          | VarExpr VarName
          | UnExpr UnOp Expr
          | BinExpr BinOp Expr Expr
          | LoadMemExpr MemOp Expr    -- expr = the address.
          | LoadRegExpr RegName
            deriving (Eq, Show)

-- Types of memory load and store operations available.
data MemOp = MemByte
           | MemByteU  -- used for loads only
           | MemHalf
           | MemHalfU  -- used for loads only
           | MemWord
             deriving (Eq, Show)

-- Statements
-- NOTE: Statements can have side effects, both 'write' (directly) and 'read' (via the Exprs they contain).
data Statement = Let VarName Expr           -- VarNames should be unique within a basic block
               | StoreMem MemOp Expr Expr   -- first expr = target addr; second expr = value to be stored
               | StoreReg RegName Expr
               | Jump CondExpr Addr Addr    -- if condition true, goto first addr, else goto second.
               | IndirectJump Expr
               | Syscall Addr               -- do a syscall, then continue from Addr
               | Break                      -- debugger breakpoint instruction
                 deriving (Eq, Show)

-- Conditional expressions, used for branches.
-- NOTE: CondOps are assumed to be signed, except where there is a U suffix.
data CondExpr = BinCond CondOp Expr Expr
              | LitCond Bool
                deriving (Eq, Show)

data CondOp = Equal
            | NotEqual
            | GtrThan
            | LessThan
            | GtrEqual
            | LessEqual
            | GtrThanU
            | LessThanU
            | GtrEqualU
            | LessEqualU
              deriving (Eq, Show)


-- Useful functions for working with CondExprs
applyCond :: CondOp -> Int32 -> Int32 -> Bool
applyCond Equal = (==)
applyCond NotEqual = (/=)
applyCond GtrThan = (>)
applyCond LessThan = (<)
applyCond GtrEqual = (>=)
applyCond LessEqual = (<=)
applyCond GtrThanU = unsignedCond (>)
applyCond LessThanU = unsignedCond (<)
applyCond GtrEqualU = unsignedCond (>=)
applyCond LessEqualU = unsignedCond (<=)

unsignedCond :: (Word32->Word32->Bool) -> Int32 -> Int32 -> Bool
unsignedCond op a b = ((fromIntegral a)::Word32) `op` ((fromIntegral b)::Word32)


-- Mapping functions
-- Function to map over all the expressions in a statement.
mapOverExprs :: (Expr -> Expr) -> Statement -> Statement
mapOverExprs f (Let v e) = Let v (f e)
mapOverExprs f (StoreMem m e1 e2) = StoreMem m (f e1) (f e2)
mapOverExprs f (StoreReg n e) = StoreReg n (f e)
mapOverExprs f (Jump c a1 a2) = Jump (mapOverExprsC f c) a1 a2
mapOverExprs f (IndirectJump e) = IndirectJump (f e)
mapOverExprs f (Syscall a) = (Syscall a)
mapOverExprs f Break = Break

mapOverExprsC :: (Expr -> Expr) -> CondExpr -> CondExpr
mapOverExprsC f (BinCond op e1 e2) = BinCond op (f e1) (f e2)
mapOverExprsC f c@(LitCond _) = c

mapOverCondExprs :: (CondExpr -> CondExpr) -> Statement -> Statement
mapOverCondExprs f (Jump c a1 a2) = Jump (f c) a1 a2
mapOverCondExprs _ s = s

-- Finding functions
findExprsInStmt :: Statement -> [Expr]
findExprsInStmt (Let _ e) = [e]
findExprsInStmt (StoreMem _ e1 e2) = [e1, e2]
findExprsInStmt (StoreReg _ e) = [e]
findExprsInStmt (Jump c _ _) = findExprsInCondExpr c
findExprsInStmt (IndirectJump e) = [e]
findExprsInStmt (Syscall _) = []
findExprsInStmt Break = []

findExprsInCondExpr :: CondExpr -> [Expr]
findExprsInCondExpr (BinCond _ e1 e2) = [e1, e2]
findExprsInCondExpr (LitCond _) = []

findVarsInExpr :: Expr -> [VarName]
findVarsInExpr (LitExpr _) = []
findVarsInExpr (VarExpr v) = [v]
findVarsInExpr (UnExpr _ e) = findVarsInExpr e
findVarsInExpr (BinExpr _ e1 e2) = findVarsInExpr e1 ++ findVarsInExpr e2
findVarsInExpr (LoadMemExpr _ e) = findVarsInExpr e
findVarsInExpr (LoadRegExpr _) = []
