-- MODULE:
--   Risc2cpp.LocalVarAlloc
--
-- PURPOSE:
--   Renames the variables in Let statements to minimize the number of
--   local variables used by a basic block. The local variables will
--   have names "z0", "z1", "z2" etc.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   7-Aug-2011
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2011, 2025.
--
--   This file is part of Risc2cpp. Risc2cpp is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.

module Risc2cpp.LocalVarAlloc

    ( allocLocalVars )    -- [Statement] -> [Statement]

where

import Risc2cpp.Intermediate
import Risc2cpp.Misc

import Data.List
import qualified Data.Map as Map
import Data.Map (Map)
import Data.Maybe


-- Environment handling
type LocNum = Int
type Env = Map VarName LocNum

varToLocal :: Env -> VarName -> VarName
varToLocal env varName = "z" ++ show (env Map.! varName)

substLhs :: Env -> Statement -> Statement
substLhs env (Let v e) = Let (varToLocal env v) e
substLhs env s = s

substExpr :: Env -> Expr -> Expr
substExpr env e@(LitExpr _) = e
substExpr env (VarExpr v) = VarExpr (varToLocal env v)
substExpr env (UnExpr op e) = UnExpr op (substExpr env e)
substExpr env (BinExpr op e1 e2) = BinExpr op (substExpr env e1) (substExpr env e2)
substExpr env (LoadMemExpr op e) = LoadMemExpr op (substExpr env e)
substExpr env e@(LoadRegExpr _) = e

-- 'applies' an environment to a list of statements
subst :: Env -> [Statement] -> [Statement]
subst env = map (substLhs env . mapOverExprs (substExpr env))


-- assign a new local to the given variable name.
-- takes account of which vars are still being referenced.
assignLocal :: VarName -> [Expr] -> Env -> Env
assignLocal varName exprs env = 
    let locNum = pickLocNum exprs env
    in Map.insert varName locNum env

-- pick an unused local name.
-- the local must not already be in the map, UNLESS it is unreferenced in
-- any future expression, in which case it is available for reuse.
pickLocNum :: [Expr] -> Env -> LocNum
pickLocNum exprs env = 
    let referenced = catMaybes $ map (`Map.lookup` env) (concatMap findVarsInExpr exprs)
    in pickFirstNotOf referenced

-- Finds the lowest non-negative integer that is NOT in the given list.
pickFirstNotOf :: [LocNum] -> LocNum
pickFirstNotOf xs = go 0 (uniq $ sort xs)
    where go z (x:xs) | z == x = go (z+1) xs
                      | otherwise = z
          go z [] = z

-- Input = old environment and a list of statements
-- Output = new environment
assignAllLocals :: Env -> [Statement] -> Env
assignAllLocals env ((Let v rhs):rest) = 
    let newEnv = assignLocal v (concatMap findExprsInStmt rest) env
    in assignAllLocals newEnv rest
assignAllLocals env (s:ss) = assignAllLocals env ss  -- no change to environment
assignAllLocals env [] = env


-- Top level function to rename VarExprs to local variable names.
allocLocalVars :: [Statement] -> [Statement]
allocLocalVars stmts = 
    let env = assignAllLocals Map.empty stmts
    in subst env stmts

