-- MODULE:
--   Risc2cpp.RiscV
--
-- PURPOSE:
--   Abstract representation of RISC-V assembly code. Includes a routine
--   to "disassemble" a Word32 into the abstract Insn type.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   25-Dec-2010
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011, 2025.
--
--   This file is part of Risc2cpp. Risc2cpp is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Risc2cpp.RiscV
    ( Addr
    , Reg(..)
    , Insn(..)
    , disassemble     -- Word32 -> Insn
    )

where

import Data.Bits
import Data.Int
import Data.Word
import Numeric (showHex)

type Addr = Word32

-- this derives Enum, so we can use fromEnum to convert Reg to Int, or toEnum to convert Int to Reg.
data Reg = Zero
         | RA
         | SP
         | GP
         | TP
         | T0 | T1 | T2
         | S0 | S1
         | A0 | A1 | A2 | A3 | A4 | A5 | A6 | A7
         | S2 | S3 | S4 | S5 | S6 | S7 | S8 | S9 | S10 | S11
         | T3 | T4 | T5 | T6
         deriving (Show, Eq, Ord, Enum)


-- Instruction datatype.
--
-- Notes:
--
-- Most insns are represented in the obvious way, e.g. 
--   "ADD s0, s1, s2" is represented as "ADD S0 S1 S2"
--   "SW s0, 4(s1)" is represented as "SW S0 4 S1"
--   etc
--
-- Immediate values are always taken directly from the opcode, and not transformed
-- in any way, except for conversion to Int (either sign or zero extension is applied,
-- as appropriate for the opcode in question).

data Insn = ADD Reg Reg Reg
          | ADDI Reg Reg Int
          | AND Reg Reg Reg
          | ANDI Reg Reg Int
          | AUIPC Reg Int
          | BEQ Reg Reg Int
          | BLT Reg Reg Int
          | BLTU Reg Reg Int
          | BGE Reg Reg Int
          | BGEU Reg Reg Int
          | BNE Reg Reg Int
          | DIV Reg Reg Reg
          | DIVU Reg Reg Reg
          | EBREAK
          | ECALL
          | JAL Reg Int
          | JALR Reg Int Reg
          | LB Reg Int Reg
          | LBU Reg Int Reg
          | LH Reg Int Reg
          | LHU Reg Int Reg
          | LUI Reg Int
          | LW Reg Int Reg
          | MUL Reg Reg Reg
          | MULH Reg Reg Reg
          | MULHSU Reg Reg Reg
          | MULHU Reg Reg Reg
          | OR Reg Reg Reg
          | ORI Reg Reg Int
          | REM Reg Reg Reg
          | REMU Reg Reg Reg
          | SB Reg Int Reg
          | SH Reg Int Reg
          | SLL Reg Reg Reg
          | SLLI Reg Reg Int
          | SLT Reg Reg Reg
          | SLTI Reg Reg Int
          | SLTIU Reg Reg Int
          | SLTU Reg Reg Reg
          | SRA Reg Reg Reg
          | SRAI Reg Reg Int
          | SRL Reg Reg Reg
          | SRLI Reg Reg Int
          | SUB Reg Reg Reg
          | SW Reg Int Reg
          | XOR Reg Reg Reg
          | XORI Reg Reg Int
            deriving (Show)

disassemble :: Word32 -> Insn
disassemble insn =
    let opcode, funct3, funct7, imm :: Int
        rd, rs1, rs2 :: Reg
        opcode = fromIntegral (insn .&. 0x7f)
        rd = (toEnum . fromIntegral) ((insn `shiftR` 7) .&. 0x1f)
        funct3 = fromIntegral ((insn `shiftR` 12) .&. 0x7)
        rs1 = (toEnum . fromIntegral) ((insn `shiftR` 15) .&. 0x1f)
        rs2 = (toEnum . fromIntegral) ((insn `shiftR` 20) .&. 0x1f)
        funct7 = fromIntegral ((insn `shiftR` 25) .&. 0x7f)
        imm = fromIntegral ((fromIntegral insn :: Int32) `shiftR` 20)
    in case opcode of
         0x03 -> decodeLoad funct3 rd imm rs1
         0x13 -> decodeIType funct3 rd rs1 imm
         0x17 -> AUIPC rd (fromIntegral (insn `shiftR` 12))
         0x23 -> decodeStore funct3 rs2 (storeImm insn) rs1
         0x33 -> decodeRType funct7 funct3 rd rs1 rs2
         0x37 -> LUI rd (fromIntegral (insn `shiftR` 12))
         0x63 -> decodeBranch funct3 rs1 rs2 (branchImm insn)
         0x6f -> JAL rd (jalImm insn)
         0x67 -> JALR rd imm rs1
         0x73 -> case insn of
                   0x00000073 -> ECALL
                   _ -> EBREAK  -- Assume any other 0x73 insn is ebreak !
         _ -> error $ "Illegal opcode (insn = " ++ showHex insn "" ++ ")"

storeImm :: Word32 -> Int
storeImm insn =
    fromIntegral
     ( (((fromIntegral insn :: Int32) `shiftR` 25) `shiftL` 5)
       .|.
       (fromIntegral ((insn `shiftR` 7) .&. 0x1f))
     )

branchImm :: Word32 -> Int
branchImm insn =
    let a = ((insn `shiftR` 31) .&. 1) `shiftL` 12
        b = ((insn `shiftR` 7) .&. 1) `shiftL` 11
        c = ((insn `shiftR` 25) .&. 0x3f) `shiftL` 5
        d = ((insn `shiftR` 8) .&. 0xf) `shiftL` 1
        combined = a .|. b .|. c .|. d
        signExtend = if (combined .&. 0x1000) /= 0
                     then combined .|. 0xffffe000
                     else combined
    in fromIntegral (fromIntegral signExtend :: Int32)

jalImm :: Word32 -> Int
jalImm insn =
    let a = ((insn `shiftR` 31) .&. 1) `shiftL` 20
        b = ((insn `shiftR` 12) .&. 0xff) `shiftL` 12
        c = ((insn `shiftR` 20) .&. 1) `shiftL` 11
        d = ((insn `shiftR` 21) .&. 0x3ff) `shiftL` 1
        combined = a .|. b .|. c .|. d
        signExtend = if (combined .&. 0x100000) /= 0
                     then combined .|. 0xfff00000
                     else combined
    in fromIntegral (fromIntegral signExtend :: Int32)

-- Load instructions (opcode 0x03)
decodeLoad :: Int -> Reg -> Int -> Reg -> Insn
decodeLoad 0 = LB
decodeLoad 1 = LH
decodeLoad 2 = LW
decodeLoad 4 = LBU
decodeLoad 5 = LHU
decodeLoad _ = error "Illegal load instruction"

-- 'I' type instructions (opcode 0x13)
decodeIType :: Int -> Reg -> Reg -> Int -> Insn
decodeIType 0 = ADDI
decodeIType 1 = SLLI
decodeIType 2 = SLTI
decodeIType 3 = SLTIU
decodeIType 4 = XORI
decodeIType 5 = (\rd rs1 imm ->
                     let shamt = imm .&. 0x1f in
                     if (imm .&. 0xfe0) == 0 then SRLI rd rs1 shamt
                     else if (imm .&. 0xfe0) == 0x400 then SRAI rd rs1 shamt
                          else error "Illegal I-type instruction")
decodeIType 6 = ORI
decodeIType 7 = ANDI

-- Store instructions (opcode 0x23)
decodeStore :: Int -> Reg -> Int -> Reg -> Insn
decodeStore 0 = SB
decodeStore 1 = SH
decodeStore 2 = SW
decodeStore _ = error "Illegal store instruction"

-- 'R' type instructions (opcode 0x33)
decodeRType :: Int -> Int -> Reg -> Reg -> Reg -> Insn
decodeRType 0 0 = ADD
decodeRType 0 1 = SLL
decodeRType 0 2 = SLT
decodeRType 0 3 = SLTU
decodeRType 0 4 = XOR
decodeRType 0 5 = SRL
decodeRType 0 6 = OR
decodeRType 0 7 = AND
decodeRType 1 0 = MUL
decodeRType 1 1 = MULH
decodeRType 1 2 = MULHSU
decodeRType 1 3 = MULHU
decodeRType 1 4 = DIV
decodeRType 1 5 = DIVU
decodeRType 1 6 = REM
decodeRType 1 7 = REMU
decodeRType 32 0 = SUB
decodeRType 32 5 = SRA
decodeRType _ _ = error "Illegal R-type instruction"

-- Branch instructions (opcode 0x63)
decodeBranch :: Int -> Reg -> Reg -> Int -> Insn
decodeBranch 0 = BEQ
decodeBranch 1 = BNE
decodeBranch 4 = BLT
decodeBranch 5 = BGE
decodeBranch 6 = BLTU
decodeBranch 7 = BGEU
decodeBranch _ = error "Illegal branch instruction"
