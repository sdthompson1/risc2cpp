-- MODULE:
--   Risc2cpp.RiscVToIntermed
--
-- PURPOSE:
--   Converts RiscV Insns to Intermediate Statements and Exprs.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   27-Dec-2010
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011, 2025.
--
--   This file is part of Risc2cpp. Risc2cpp is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Risc2cpp.RiscVToIntermed
    ( riscVToIntermed  -- [Addr] -> [(Addr, [Insn])] -> ([Addr], [(Addr, [Statement])])
    )

where

import Risc2cpp.RiscV hiding (Addr)
import Risc2cpp.Misc
import Risc2cpp.Intermediate

import Data.Bits
import Data.Char
import Data.Int
import Data.List
import qualified Data.Map as Map
import Data.Map (Map)
import Data.Maybe
import Data.Word


-- Register names
getRegName :: Reg -> RegName
getRegName Zero = error "regName Zero"
getRegName r = map toLower (show r)

-- Find an expr corresponding to the given register
loadReg :: Reg -> Expr
loadReg Zero = LitExpr 0
loadReg reg = LoadRegExpr (getRegName reg) 

-- Make an Expr out of an immediate Int value
-- NOTE: This will sign extend the value to Int32
immediate :: Int -> Expr
immediate = LitExpr . fromIntegral

-- construct a StoreReg from a BinOp applied to two regs
makeBin :: BinOp -> Reg -> Reg -> Reg -> [Statement]
makeBin _ Zero _ _ = []
makeBin op dest src1 src2 = [StoreReg (getRegName dest) (BinExpr op (loadReg src1) (loadReg src2))]

-- shift version of makeBin (src2 is AND-ed with 0x1f)
makeBinShift :: BinOp -> Reg -> Reg -> Reg -> [Statement]
makeBinShift _ Zero _ _ = []
makeBinShift op dest src1 src2 = [StoreReg (getRegName dest)
                                  (BinExpr op (loadReg src1)
                                   (BinExpr And (loadReg src2) (LitExpr 0x1f)))]

-- construct a StoreReg from a BinOp applied to a Reg and an immediate value
makeBinI :: BinOp -> Reg -> Reg -> Int -> [Statement]
makeBinI _ Zero _ _ = []
makeBinI op dest srcR srcI = [StoreReg (getRegName dest) (BinExpr op (loadReg srcR) (immediate srcI))]

-- construct a StoreReg statement for an LUI instruction
makeLUI :: Reg -> Int -> [Statement]
makeLUI Zero _ = []
makeLUI reg value = [StoreReg (getRegName reg) (LitExpr val)]
    where val :: Int32
          val = (fromIntegral value) `shiftL` 12

-- construct a StoreReg statement for an AUIPC instruction
makeAUIPC :: Addr -> Reg -> Int -> [Statement]
makeAUIPC _ Zero _ = []
makeAUIPC pc reg imm = [StoreReg (getRegName reg) (LitExpr val)]
    where val :: Int32
          val = ((fromIntegral imm :: Int32) `shiftL` 12) + (fromIntegral pc :: Int32)

-- construct a StoreReg statement for a load from memory.
makeLoad :: Reg -> MemOp -> Int -> Reg -> [Statement]
makeLoad Zero _ _ _ = []
makeLoad destReg op offset addrReg = 
    [StoreReg (getRegName destReg) (LoadMemExpr op (BinExpr Add (immediate offset) (loadReg addrReg)))]

-- construct a StoreMem statement
mkStore :: Reg -> MemOp -> Int -> Reg -> [Statement]
mkStore srcReg op offset addrReg = 
    let srcExpr = loadReg srcReg
        addrExpr = BinExpr Add (immediate offset) (loadReg addrReg)
    in [StoreMem op addrExpr srcExpr]

-- add an Int to an address
addAddress :: Addr -> Int -> Addr
addAddress addr offset =
    let offset32 :: Int32
        offset32 = fromIntegral offset
        offsetWord :: Word32
        offsetWord = fromIntegral offset32
    in addr + offsetWord

-- construct statement for a branch instruction
makeBranch :: Addr -> CondOp -> Reg -> Reg -> Int -> [Statement]
makeBranch pc op src1 src2 offset =
    [Jump (BinCond op (loadReg src1) (loadReg src2))
          (addAddress pc offset)
          (pc + 4)]

-- helper for makeJAL and makeJALR
linkInsns :: Addr -> Reg -> [Statement]
linkInsns _ Zero = []
linkInsns pc reg = [StoreReg (getRegName reg) (LitExpr (fromIntegral (pc + 4)))]

-- construct statements for a JAL
makeJAL :: Addr -> Reg -> Int -> [Statement]
makeJAL pc dest imm =
    linkInsns pc dest ++ [Jump (LitCond True) (addAddress pc imm) 0]

-- construct statements for a JALR
makeJALR :: Addr -> Reg -> Int -> Reg -> [Statement]
makeJALR pc dest imm src1 =
    linkInsns pc dest ++
        [IndirectJump
         (BinExpr And
          (BinExpr Add (loadReg src1) (LitExpr (fromIntegral imm :: Int32)))
          (LitExpr (fromIntegral (0xfffffffe::Word32))))]

-- Converts an instruction into 1 or more Statements.
convertInsn :: Addr -> Insn -> [Statement]
convertInsn _ (ADD dest src1 src2) = makeBin Add dest src1 src2
convertInsn _ (ADDI dest srcR srcI) = makeBinI Add dest srcR srcI
convertInsn _ (AND dest src1 src2) = makeBin And dest src1 src2
convertInsn _ (ANDI dest srcR srcI) = makeBinI And dest srcR srcI
convertInsn pc (AUIPC dest imm) = makeAUIPC pc dest imm
convertInsn pc (BEQ src1 src2 imm) = makeBranch pc Equal src1 src2 imm
convertInsn pc (BLT src1 src2 imm) = makeBranch pc LessThan src1 src2 imm
convertInsn pc (BLTU src1 src2 imm) = makeBranch pc LessThanU src1 src2 imm
convertInsn pc (BGE src1 src2 imm) = makeBranch pc GtrEqual src1 src2 imm
convertInsn pc (BGEU src1 src2 imm) = makeBranch pc GtrEqualU src1 src2 imm
convertInsn pc (BNE src1 src2 imm) = makeBranch pc NotEqual src1 src2 imm
convertInsn _ (DIV dest src1 src2) = makeBin Quot dest src1 src2
convertInsn _ (DIVU dest src1 src2) = makeBin QuotU dest src1 src2
convertInsn pc EBREAK = [Break]
convertInsn pc ECALL = [Syscall (pc+4)]
convertInsn pc (JAL dest imm) = makeJAL pc dest imm
convertInsn pc (JALR dest imm src1) = makeJALR pc dest imm src1
convertInsn _ (LB dest offset areg) = makeLoad dest MemByte offset areg
convertInsn _ (LBU dest offset areg) = makeLoad dest MemByteU offset areg
convertInsn _ (LH dest offset areg) = makeLoad dest MemHalf offset areg
convertInsn _ (LHU dest offset areg) = makeLoad dest MemHalfU offset areg
convertInsn _ (LUI dest value) = makeLUI dest value
convertInsn _ (LW dest offset areg) = makeLoad dest MemWord offset areg
convertInsn _ (MUL dest src1 src2) = makeBin Mult dest src1 src2
convertInsn _ (MULH dest src1 src2) = makeBin MultHi dest src1 src2
convertInsn _ (MULHSU dest src1 src2) = makeBin MultHiSU dest src1 src2
convertInsn _ (MULHU dest src1 src2) = makeBin MultHiU dest src1 src2
convertInsn _ (OR dest src1 src2) = makeBin Or dest src1 src2
convertInsn _ (ORI dest srcR srcI) = makeBinI Or dest srcR srcI
convertInsn _ (REM dest src1 src2) = makeBin Rem dest src1 src2
convertInsn _ (REMU dest src1 src2) = makeBin RemU dest src1 src2
convertInsn _ (SB src offset areg) = mkStore src MemByte offset areg
convertInsn _ (SH src offset areg) = mkStore src MemHalf offset areg
convertInsn _ (SLL dest src amount) = makeBinShift LogicalShiftLeft dest src amount
convertInsn _ (SLLI dest src amount) = makeBinI LogicalShiftLeft dest src amount
convertInsn _ (SLT dest src1 src2) = makeBin SetIfLess dest src1 src2
convertInsn _ (SLTI dest srcR srcI) = makeBinI SetIfLess dest srcR srcI
convertInsn _ (SLTIU dest srcR srcI) = makeBinI SetIfLessU dest srcR srcI
convertInsn _ (SLTU dest src1 src2) = makeBin SetIfLessU dest src1 src2
convertInsn _ (SRA dest src amount) = makeBinShift ArithShiftRight dest src amount
convertInsn _ (SRAI dest src amount) = makeBinI ArithShiftRight dest src amount
convertInsn _ (SRL dest src amount) = makeBinShift LogicalShiftRight dest src amount
convertInsn _ (SRLI dest src amount) = makeBinI LogicalShiftRight dest src amount
convertInsn _ (SUB dest src1 src2) = makeBin Sub dest src1 src2
convertInsn _ (SW src offset areg) = mkStore src MemWord offset areg
convertInsn _ (XOR dest src1 src2) = makeBin Xor dest src1 src2
convertInsn _ (XORI dest srcR srcI) = makeBinI Xor dest srcR srcI

-- Convert a list of instructions into a list of (Addr,[Statement]) pairs
-- We assume the insns are sorted by address.
convertAllInsns :: [(Addr, Insn)] -> [(Addr, [Statement])]
convertAllInsns = map (\(pc,insn) -> (pc, convertInsn pc insn))


-- Finding indirect jumps from Link instructions
insnLinkTarget :: (Addr, Insn) -> Maybe Addr
insnLinkTarget (addr, insn) = case getLinkRegister insn of
                                Just Zero -> Nothing
                                Just _ -> Just (addr+4)
                                Nothing -> Nothing

getLinkRegister :: Insn -> Maybe Reg
getLinkRegister (JAL dest _) = Just dest
getLinkRegister (JALR dest _ _) = Just dest
getLinkRegister _ = Nothing


-- The main routine to convert RiscV code into the Intermediate language.
-- Inputs:
--   * indirect jumps, from relocs only. (not necessarily sorted.)
--   * instructions, as (Addr, Insn) pairs. (not necessarily sorted.)
-- Output:
--   * indirect jumps, all. (sorted, unique.)
--   * the converted Statements for each address.
riscVToIntermed :: [Addr]
                -> [(Addr, Insn)]
                -> ([Addr], [(Addr, [Statement])])
riscVToIntermed inputIndirectTargets insns =
    let linkTargets = catMaybes $ map insnLinkTarget insns
        allIndirectTargets = (uniq . sort) (linkTargets ++ inputIndirectTargets) -- sorted
        convertedInsns = convertAllInsns insns
    in (allIndirectTargets, convertedInsns)
