-- MODULE:
--   Mips2cs.BasicBlock
--
-- PURPOSE:
--   Extracts basic blocks from a chunk of Intermediate code
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   6-Aug-2011
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011.
--
--   This file is part of Mips2cs. Mips2cs is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.

module Mips2cs.BasicBlock 

    ( findBasicBlocks )     -- [Addr] -> [(Addr, [Statement])] -> ([Addr], Map Addr [Statement])                           

where

import Mips2cs.Intermediate
import Mips2cs.Misc

import Data.List
import qualified Data.Map as Map
import Data.Map (Map)


type AddrWithStmts = (Addr, [Statement])

-- Input:
--  * all indirect jump targets
--  * intermediate code (a list of (Addr, [Statement]) pairs -- one for each machine level instruction)
-- Assumptions:
--  * input [Statement] lists contain at most one Jump/IndirectJump, and if it exists, it is at the end of the list.
--  * input addrsWithStmts is sorted in ascending order of address
--  * indirect jump targets list is NOT necessarily sorted
-- Process:
--  * Splits the code into basic blocks at:
--     * the input indirect jump addresses
--     * any direct jump targets found in the code
-- Output:
--  * a list of "kernel" addresses that the code jumps to. (>=0x10 and <=0xffff)
--  * the list of basic blocks (a map of Addr to [Statement] -- one entry for each basic block.)
-- Note:
--  Output basic blocks will satisfy the following condition:
--   * Final statement is a Jump or IndirectJump
--   * The other statements are all StoreReg or StoreMem.

findBasicBlocks :: [Addr] -> [AddrWithStmts] -> ([Addr], Map Addr [Statement])
findBasicBlocks indirectJumpTargets addrsWithStmts =
    let allStmts = concat (map snd addrsWithStmts)
        allDirectTargets = concatMap findDirectJumpTargets allStmts
        sortedTargets = (uniq . sort) (allDirectTargets ++ indirectJumpTargets)
        (kernelAddrs, jumpAddrs) = span (<0x10000) sortedTargets

        splitByJumpTargets' = splitUpList jumpAddrs addrsWithStmts   :: [[AddrWithStmts]]
        splitByJumpTargets = removeHeadIfEmpty splitByJumpTargets'  -- needed in case very first addr is actually a jump target
        truncated = map truncateAfterJump splitByJumpTargets        :: [[AddrWithStmts]]
        combined = map combineInsns truncated                       :: [AddrWithStmts]
        basicBlocks = map addJumpIfNeeded (zip combined (tail combined ++ [error "Fell through final block!"] ))

    in (dropWhile (<0x10) kernelAddrs, Map.fromList basicBlocks)

findDirectJumpTargets :: Statement -> [Addr]
findDirectJumpTargets (Jump _ a1 a2) = [a1,a2]
findDirectJumpTargets _ = []

splitUpList :: [Addr] -> [AddrWithStmts] -> [[AddrWithStmts]]
splitUpList [] insns = [insns]
splitUpList (end:ends) insns = 
    let (thisChunk, nextChunks) = span ((<end) . fst) insns
    in (thisChunk : splitUpList ends nextChunks)

-- this removes unreachable code in between two basic blocks
-- (e.g. this can be caused by mips delay slots)
truncateAfterJump :: [AddrWithStmts] -> [AddrWithStmts]
truncateAfterJump insns = 
    let (beforeJump, jumpAndLater) = break (endsWithJump . snd) insns
    in case jumpAndLater of
         (jump:later) -> (beforeJump ++ [jump])   -- Keep the jump but drop everything afterwards.
         [] -> beforeJump  -- No jump was found, so keep everything

endsWithJump :: [Statement] -> Bool
endsWithJump [] = False
endsWithJump xs = case (last xs) of
                    Jump _ _ _ -> True
                    IndirectJump _ -> True
                    _ -> False

combineInsns :: [AddrWithStmts] -> AddrWithStmts
combineInsns [] = error "combineInsns: Empty block!"
combineInsns ((a,stmts):rest) = (a, stmts ++ concatMap snd rest)

addJumpIfNeeded :: (AddrWithStmts, AddrWithStmts) -> AddrWithStmts
addJumpIfNeeded (thisBlock@(thisAddr, thisStmts), nextBlock) 
    | endsWithJump thisStmts = thisBlock
    | otherwise = case nextBlock of
                    (nextAddr, _) -> (thisAddr, thisStmts ++ [Jump (LitCond True) nextAddr nextAddr])


removeHeadIfEmpty :: [[a]] -> [[a]]
removeHeadIfEmpty ([]:xs) = xs
removeHeadIfEmpty xs = xs
