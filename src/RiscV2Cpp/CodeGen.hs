-- MODULE:
--   Mips2cs.CodeGen
--
-- PURPOSE:
--   Generate C# code from a list of Statements
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   9-Jan-2011
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2011.
--
--   This file is part of Mips2cs. Mips2cs is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Mips2cs.CodeGen ( codeGen )

where

import Mips2cs.Intermediate
import Mips2cs.Misc

import Data.Bits
import Data.Char
import Data.Int
import Data.List
import qualified Data.Map as Map
import Data.Map (Map)
import Data.Maybe
import Data.Word
import Numeric


-- Code for InitMem function

initMem :: [(Word32, [Word32])] -> [String]
initMem dataChunks = 
    let header = ["    public void InitMem()"
                 ,"    {"
                 ]
        footer = ["    }", ""]
    in header ++ concatMap makeDataPage dataChunks ++ footer

makeDataPage :: (Word32, [Word32]) -> [String]
makeDataPage (addr, words) 
    | all (==0) words = 
        ["        mem[" ++ show pageNum ++ "] = new int[" ++ show (length words) ++ "];"]
    | otherwise = 
        ["        mem[" ++ show pageNum ++ "] = new int[] {"]
          ++ map arrayInitializer (blocks words)
          ++ ["        };"]
              where blocks [] = []
                    blocks xs = let (a,b) = splitAt 16 xs in a : blocks b
                    pageNum = addr `shiftR` 16

arrayInitializer :: [Word32] -> String
arrayInitializer y = "            " ++ concatMap (\x -> show ((fromIntegral x)::Int32) ++ ", ") y


-- Code Generation

memFunction :: MemOp -> String
memFunction MemByte = "Byte"
memFunction MemByteU = "ByteU"
memFunction MemHalf = "Half"
memFunction MemHalfU = "HalfU"
memFunction MemWord = "Word"

genBinOp :: BinOp -> String
genBinOp Add = "+"
genBinOp And = "&"
genBinOp Quot = "/"
genBinOp Rem = "%"
genBinOp Mult = "*"
genBinOp Or = "|"
genBinOp LogicalShiftLeft = "<<"
genBinOp ArithShiftRight = ">>"
genBinOp Sub = "-"
genBinOp Xor = "^"

genCondOp :: CondOp -> String
genCondOp Equal = "=="
genCondOp NotEqual = "!="
genCondOp GtrThan = ">"
genCondOp LessThan = "<"
genCondOp GtrEqual = ">="
genCondOp LessEqual = "<="

castToUint :: Expr -> String
castToUint = castToUnsigned "(uint)"

castToUlong :: Expr -> String
castToUlong = castToUnsigned "(ulong)(uint)"

castToUnsigned :: String -> Expr -> String
castToUnsigned _ (LitExpr i) = show (fromIntegral i :: Word32) ++ "u"
castToUnsigned typ expr = "(" ++ typ ++ genExpr expr ++ ")"

unsignedExpr :: Expr -> String -> Expr -> String
unsignedExpr lhs op rhs = "( (int)( " ++ castToUint lhs ++ " " ++ op ++ " " ++ castToUint rhs ++ " ))"

genExpr :: Expr -> String
genExpr (LitExpr i) = show i
genExpr (VarExpr v) = v
genExpr (UnExpr Negate x) = "(-" ++ genExpr x ++ ")"
genExpr (UnExpr Not x) = "(~" ++ genExpr x ++ ")"
genExpr (BinExpr CheckedAdd lhs rhs) = "checked(" ++ genExpr lhs ++ " + " ++ genExpr rhs ++ ")"
genExpr (BinExpr CheckedSub lhs rhs) = "checked(" ++ genExpr lhs ++ " - " ++ genExpr rhs ++ ")"
genExpr (BinExpr MultU lhs rhs) = unsignedExpr lhs "*" rhs
genExpr (BinExpr MultHi lhs rhs) = "( (int)(( (long)" ++ genExpr lhs ++ " * (long)" ++ genExpr rhs ++ " ) >> 32))"
genExpr (BinExpr MultHiU lhs rhs) = "( (int)(( " ++ castToUlong lhs ++ " * " ++ castToUlong rhs ++ " ) >> 32))"
genExpr (BinExpr QuotU lhs rhs) = unsignedExpr lhs "/" rhs
genExpr (BinExpr RemU lhs rhs) = unsignedExpr lhs "%" rhs
genExpr (BinExpr LogicalShiftRight lhs rhs) = "( (int)( " ++ castToUint lhs ++ " >> " ++ genExpr rhs ++ " ))"
genExpr (BinExpr SetIfLess lhs rhs) = "(" ++ genExpr lhs ++ " < " ++ genExpr rhs ++ " ? 1 : 0)"
genExpr (BinExpr SetIfLessU lhs rhs) = "(" ++ castToUint lhs ++ " < " ++ castToUint rhs ++ " ? 1 : 0)"
genExpr (BinExpr op lhs rhs) = "(" ++ genExpr lhs ++ " " ++ genBinOp op ++ " " ++ genExpr rhs ++ ")"
genExpr (LoadMemExpr op addr) = "Read" ++ memFunction op ++ "(" ++ genExpr addr ++ ")"
genExpr (LoadRegExpr reg) = reg

genCondExpr :: CondExpr -> String
genCondExpr (BinCond LessThanU lhs rhs) = castToUint lhs ++ " < " ++ castToUint rhs
genCondExpr (BinCond GtrEqualU lhs rhs) = castToUint lhs ++ " >= " ++ castToUint rhs
genCondExpr (BinCond op lhs rhs) = genExpr lhs ++ " " ++ genCondOp op ++ " " ++ genExpr rhs
genCondExpr (LitCond True) = "true"
genCondExpr (LitCond False) = "false"

-- generate c# code for a single statement.
-- note: generated code is not indented.
genStmt :: Map Addr Int -> Int -> Statement -> String
genStmt _ _ (Let varName rhs) =
   varName ++ " = " ++ genExpr rhs ++ ";"
genStmt _ _ (StoreMem op addr value) =
   "Write" ++ memFunction op ++ "(" ++ genExpr addr ++ ", " ++ genExpr value ++ ");"
genStmt _ _ (StoreReg regName rhs) =
   regName ++ " = " ++ genExpr rhs ++ ";"
genStmt blockNos firstBlockNum (Jump cond addrTrue addrFalse) = 
    case cond of 
      LitCond True -> genJump blockNos firstBlockNum addrTrue
      LitCond False -> genJump blockNos firstBlockNum addrFalse
      _ -> "if (" ++ genCondExpr cond ++ ") { "
           ++ genJump blockNos firstBlockNum addrTrue ++ " } else { "
           ++ genJump blockNos firstBlockNum addrFalse ++ " }"
genStmt _ _ (IndirectJump addr) = 
    "return case_table[" ++ genExpr addr ++ "];"

genJump :: Map Addr Int -> Int -> Addr -> String
genJump blockNos firstBlockNum addr = 
    let label = case Map.lookup addr blockNos of
                  Just x -> x
                  Nothing -> error $ "Missing case label for address: " ++ toHex addr
    in if label >= firstBlockNum && label < firstBlockNum + numBlocksPerMethod then
           "goto case " ++ show (label .&. (numBlocksPerMethod - 1)) ++ ";"
       else "return " ++ show label ++ ";"

-- add indentation
indent :: Int -> String -> String
indent n s = (take n (repeat ' ')) ++ s

-- generate 'full' code for a basic block
-- including case label & indentation
genBasicBlock :: Map Addr Int -> Int -> (Addr, [Statement]) -> [String]
genBasicBlock allBlockNos firstBlockNum (addr, stmts) = 
    let innerCaseNum = (allBlockNos Map.! addr) .&. (numBlocksPerMethod - 1)
        code = map (genStmt allBlockNos firstBlockNum) stmts   :: [String]
        caseLabel = "case " ++ show innerCaseNum ++ ":  // " ++ toHex addr
    in [caseLabel] ++ map (indent 4) code ++ [""]



-- Prologue -- output at the start of the generated source file.
prologue :: Word32 -> Word32 -> [Addr] -> [RegName] -> [String]
prologue topOfHeap startAddr kernelAddrs regs = 
    ["// This file was generated by Mips2cs"
    ,""
    ,"using System;"
    ,"using System.Collections.Generic;"
    ,""
    ,""
    ,"//"
    ,"// Interface for Mips code to call back to C#"
    ,"// We pass the MipsVM object (so that memory can be accessed) as well"
    ,"// as registers a0 to a3 (input params). Return value will be passed"
    ,"// back to the MIPS in v0."
    ,"//"
    ,"public interface MipsCallbacks"
    ,"{"
    ]
    ++ map makeKernelInterface kernelAddrs
    ++ ["};"
       ,""
       ,""
       ,"//"
       ,"// The MipsVM class itself"
       ,"//"
       ,"public class MipsVM"
       ,"{"
       ,"    // CONSTRUCTOR"
       ,""
       ,"    public MipsVM(MipsCallbacks cb)"
       ,"    {"
       ,"        // Allocate 'page table'. All pages are NULL (i.e. unallocated) initially."
       ,"        mem = new int[65536][];"
       ,""
       ,"        // Initialize all registers (except ra) to zero"]
    ++ map (\r -> "        " ++ r ++ " = 0;") (filter (/="ra") regs)
    ++ [""
       ,"        // Initialize ra to the start address"
       ,"        ra = " ++ toHex startAddr ++ ";"
       ,""
       ,"        // Store our reference to the callbacks object"
       ,"        callbacks = cb;"
       ,""
       ,"        // Allocate one page for the stack"
       ,"        mem[0xffff] = new int[16384];"
       ,""
       ,"        // Set top_of_heap (end of code, rounded up to next 64K page)"
       ,"        top_of_heap = " ++ toHex ((topOfHeap + 0x0000ffff) .&. 0xffff0000) ++ ";"
       ,""
       ,"        // Allocate the data and BSS pages"
       ,"        InitMem();"
       ,""
       ,"        // Initialize case table"
       ,"        InitCaseTable();"
       ,"    }"
       ,""
       ,""
       ,"    // MEMORY ACCESS FUNCTIONS"
       ,""
       ,"    // Read 4-byte signed integer from 4-byte aligned address"
       ,"    public int ReadWord(int addr)"
       ,"    {"
       ,"        uint a = (uint)addr;"
       ,"        return mem[a>>16][(a&0xffff)>>2];"
       ,"    }"
       ,""
       ,"    // Write 4-byte signed integer to 4-byte aligned address"
       ,"    public void WriteWord(int addr, int val)"
       ,"    {"
       ,"        uint a = (uint)addr;"
       ,"        mem[a>>16][(a&0xffff)>>2] = val;"
       ,"    }"
       ,""
       ,"    // Read 2-byte signed integer from a 2-byte aligned address"
       ,"    public int ReadHalf(int addr)"
       ,"    {"
       ,"        int word = ReadWord(addr);"
       ,"        if ((addr & 2) == 0)   // 4 byte aligned"
       ,"        {"
       ,"            return (word >> 16);   // arith shift right"
       ,"        }"
       ,"        else"
       ,"        {"
       ,"            return (int)((ushort)word);   // sign extend lower 16 bits"
       ,"        }"
       ,"    }"
       ,""
       ,"    // Read 2-byte unsigned integer from 2-byte aligned address"
       ,"    public int ReadHalfU(int addr)"
       ,"    {"
       ,"        int word = ReadWord(addr);"
       ,"        if ((addr & 2) == 0)   // 4 byte aligned"
       ,"        {"
       ,"            return (int)( ((uint)word) >> 16);   // logical shift right"
       ,"        }"
       ,"        else"
       ,"        {"
       ,"            return (word & 0x0000ffff);   // zero-extend lower 16 bits"
       ,"        }"
       ,"    }"
       ,""
       ,"    // Write 2-byte value to a 2-byte aligned address"
       ,"    public void WriteHalf(int addr, int val)"
       ,"    {"
       ,"        uint a = (uint)addr;"
       ,"        uint idx1 = a >> 16;"
       ,"        uint idx2 = (a&0xffff) >> 2;"
       ,"        int word = mem[idx1][idx2];"
       ,"        if ((a & 2) == 0)   // 4 byte aligned"
       ,"        {"
       ,"            word = (word & 0xffff) | (val << 16);"
       ,"        }"
       ,"        else"
       ,"        {"
       ,"            uint w = (uint)word;"
       ,"            uint v = (uint)val;"
       ,"            word = (int)( (w & 0xffff0000u) | (v & 0xffffu) );"
       ,"        }"
       ,"        mem[idx1][idx2] = word;"
       ,"    }"
       ,""
       ,"    // Read signed byte (from any address)"
       ,"    public int ReadByte(int addr)"
       ,"    {"
       ,"        int word = ReadWord(addr);"
       ,"        word >>= (24 - ((addr & 3)<<3));"
       ,"        return (int)((sbyte)word);   // mask, then sign extend to int"
       ,"    }"
       ,""
       ,"    // Read unsigned byte (from any address)"
       ,"    public int ReadByteU(int addr)"
       ,"    {"
       ,"        int word = ReadWord(addr);"
       ,"        word >>= (24 - ((addr & 3)<<3));"
       ,"        return (int)((byte)word);  // mask, then zero extend to int"
       ,"    }"
       ,""
       ,"    // Write a byte to any address"
       ,"    public void WriteByte(int addr, int val)"
       ,"    {"
       ,"        uint a = (uint)addr;"
       ,"        uint idx1 = a >> 16;"
       ,"        uint idx2 = (a&0xffff) >> 2;"
       ,"        uint word = (uint)(mem[idx1][idx2]);"
       ,"        uint v = (uint)val;"
       ,"        switch (a & 3)"
       ,"        {"
       ,"            case 0: word = (word & 0x00ffffffu) | (v << 24); break;"
       ,"            case 1: word = (word & 0xff00ffffu) | ((v << 16) & 0x00ff0000u); break;"
       ,"            case 2: word = (word & 0xffff00ffu) | ((v << 8) & 0x0000ff00u); break;"
       ,"            case 3: word = (word & 0xffffff00u) | (v & 0xffu); break;"
       ,"        }"
       ,"        mem[idx1][idx2] = (int)word;"
       ,"    }"
       ,""]

makeKernelInterface addr = "    int " ++ makeKernelName addr ++ "(MipsVM mips, int a0, int a1, int a2, int a3);"

-- Find all register names
findAllRegs :: [Statement] -> [RegName]
findAllRegs stmts =
    let exprs = concatMap findExprsInStmt stmts
        requiredRegs = ["ra", "a0", "a1", "a2", "a3", "v0"] -- used by callbacks, etc
    in uniq (sort (concatMap findRegsInExpr exprs ++ concatMap findRegsInStmt stmts ++ requiredRegs))

-- Find all registers referred to in a LoadReg
findRegsInExpr :: Expr -> [RegName]
findRegsInExpr (LitExpr _) = []
findRegsInExpr (VarExpr _) = []
findRegsInExpr (UnExpr _ e) = findRegsInExpr e
findRegsInExpr (BinExpr _ e1 e2) = findRegsInExpr e1 ++ findRegsInExpr e2
findRegsInExpr (LoadMemExpr _ e) = findRegsInExpr e
findRegsInExpr (LoadRegExpr r) = [r]

-- Find all registers referred to in a StoreReg
findRegsInStmt :: Statement -> [RegName]
findRegsInStmt (StoreReg r _) = [r]
findRegsInStmt _ = []


-- Private data members of the Mips class.
privateData :: [RegName] -> [String]
privateData regs = ["    // PRIVATE DATA"
                   ,""
                   ,"    // Memory (64K pages each of 64K bytes)"
                   ,"    private int[][] mem;"
                   ,""
                   ,"    // Registers"]
                   ++ map (\r -> "    private int " ++ r ++ ";") regs
                   ++ [""
                      ,"    // One past the last byte of the heap. Used by sbrk implementation."
                      ,"    private int top_of_heap;"
                      ,""
                      ,"    // Callbacks object (given to us by the caller)."
                      ,"    private MipsCallbacks callbacks;"
                      ,""
                      ,"    // Dictionary for basic block lookups"
                      ,"    Dictionary<int, int> case_table;"
                      ,""]


-- Private methods of the Mips class
privateMethods :: [String]
privateMethods =
    ["    // SBRK IMPLEMENTATION"
    ,""
    ,"    private void RunSbrk()"
    ,"    {"
    ,"        int old_top_of_heap = top_of_heap;"
    ,"        int bytes_required = a0;"
    ,"        while (top_of_heap - old_top_of_heap < bytes_required)"
    ,"        {"
    ,"            if ((top_of_heap & 0xffff) == 0)"
    ,"            {"
    ,"                // Need to allocate a new page before moving upwards"
    ,"                mem[top_of_heap>>16] = new int[16384];"
    ,"            }"
    ,"            // Move top_of_heap to start of next page"
    ,"            top_of_heap += 0x00010000;"
    ,"            top_of_heap = (int)( ((uint)top_of_heap) & 0xffff0000u );"
    ,"        }"
    ,""
    ,"        // If we have over-allocated, pull top_of_heap back down again"
    ,"        top_of_heap = old_top_of_heap + bytes_required;"
    ,""
    ,"        // Return the old top of heap in v0"
    ,"        v0 = old_top_of_heap;"
    ,"    }"
    ,""]


-- Compute the map of addr -> block number. Includes the hard coded "low addresses" (0,4,8) and the kernel addrs.
makeBlockNumsMap :: [Addr] -> Map Addr [Statement] -> Map Addr Int
makeBlockNumsMap kernelAddrs blocks = 
    let codeBlocks = zip (Map.keys blocks) [firstRealBlockNum..]
        kernelBlocks = map (\a -> (a, fromIntegral $ a `div` 4)) kernelAddrs
        fixedBlocks = [(0,0), (4,1), (8,2)]
    in Map.fromAscList (fixedBlocks ++ kernelBlocks ++ codeBlocks)


-- Parameters for trampoline
trampolineShift = 8

numBlocksPerMethod :: Int
numBlocksPerMethod = 1 `shiftL` trampolineShift

firstRealBlockNum :: Int
firstRealBlockNum = 16384    -- This should be a multiple of numBlocksPerMethod


-- Code for 'run' method (the trampoline)
makeTrampoline :: Int -> [Addr] -> [String]
makeTrampoline numCodeChunks kernelAddrs = 
    ["    // RUN METHOD (TRAMPOLINE)"
    ,""
    ,"    public void Run()"
    ,"    {"
    ,"        int bb = case_table[ra];"
    ,""
    ,"        while (true)"
    ,"        {"
    ,"            int bx = bb & " ++ show (numBlocksPerMethod - 1) ++ ";"
    ,"            switch (bb >> " ++ show trampolineShift ++ ")"
    ,"            {"
       -- TODO: This is not going to work beyond first 64 kernel routines
       -- because they will go into case 1, case 2 etc ...
    ,"            case 0:   // Special block numbers."
    ,"                switch (bb)"
    ,"                {"
    ,"                case 0:  // Halt"
    ,"                    ra = -1;"
    ,"                    return;"
    ,""
    ,"                case 1:  // Yield"
    ,"                    return;"
    ,""
    ,"                case 2:  // Sbrk"
    ,"                    RunSbrk();"
    ,"                    bb = case_table[ra];"
    ,"                    break;"
    ]
    ++ concatMap makeKernelCase kernelAddrs
    ++ [""
       ,"                default:"
       ,"                    throw new ApplicationException(\"Invalid jump to low memory\");"
       ,"                }"
       ,"                break;"
       ,""]
    ++ map makeTrampolineCase [firstCaseNum .. firstCaseNum + numCodeChunks - 1]
    ++ ["            default:"
       ,"                throw new ApplicationException(\"Invalid jump\");"
       ,"            }"
       ,"        }"
       ,"    }"
       ,""]
     where firstCaseNum = firstRealBlockNum `shiftR` trampolineShift

makeKernelCase :: Addr -> [String]
makeKernelCase addr = 
    [""
    ,"                case " ++ show (addr `div` 4) ++ ":"
    ,"                    v0 = callbacks." ++ makeKernelName addr ++ "(this, a0, a1, a2, a3);"
    ,"                    bb = case_table[ra];"
    ,"                    break;"
    ]

makeKernelName addr = "f_" ++ showIntAtBase 16 intToDigit addr ""

makeTrampolineCase :: Int -> String
makeTrampolineCase n = "            case " ++ show n ++ ": bb = Exec" ++ show n ++ "(bx); break;"

-- Code for the individual 'exec' methods
makeExecMethod :: Int -> [(Addr, [Statement])] -> Map Addr Int -> [String]
makeExecMethod firstBlock blocks blockNumMap = 
    ["    private int Exec" ++ show outerBlockNum ++ "(int bx)"
    ,"    {"]
    ++ declareLocals (concatMap snd blocks)
    ++ ["        switch (bx)"
       ,"        {"]
       ++ codeStrings
       ++ ["        }"
          ,"        throw new ApplicationException(\"Invalid block number\");"
          ,"    }"
          ,""]
   where
     outerBlockNum = firstBlock `shiftR` trampolineShift
     codeStrings' = concatMap (genBasicBlock blockNumMap firstBlock) blocks :: [String]
     codeStrings = map (indent 8) codeStrings'


declareLocals :: [Statement] -> [String]
declareLocals stmts = 
    let exprs = concatMap findExprsInStmt stmts
        vars = uniq $ sort $ concatMap findVarsInExpr exprs
    in map (\x -> "        int " ++ x ++ ";") vars



initCaseTable :: Map Addr Int -> [Addr] -> [String]
initCaseTable addrToCase addrs = ["    // CASE TABLE IMPLEMENTATION"
                                 ,""
                                 ,"    private void InitCaseTable()"
                                 ,"    {"
                                 ,"        case_table = new Dictionary<int,int>();"]
                                 ++ map (\a -> "        case_table[" ++ (toHex a) ++ "] = " ++ show (addrToCase Map.! a) ++ ";") addrs
                                 ++ ["    }"
                                    ,""]

codeGen :: Map Addr [Statement] -> [Addr] -> [Addr] -> [(Word32, [Word32])] -> Word32 -> [String]
codeGen blocks indirectJumpTargets kernelAddrs dataChunks entryPoint = 
    let blockMap = makeBlockNumsMap kernelAddrs blocks
        registers = findAllRegs (concat (Map.elems blocks))
    in 
      prologue 0x10000000 entryPoint kernelAddrs registers  -- TODO: proper top of heap address
      ++ makeTrampoline (length codeChunks) kernelAddrs
      ++ concatMap (\(x,n) -> makeExecMethod n x blockMap) (zip codeChunks [firstRealBlockNum, firstRealBlockNum + numBlocksPerMethod ..])
      ++ privateMethods
      ++ initCaseTable blockMap (uniq $ sort indirectJumpTargets)
      ++ initMem dataChunks
      ++ privateData registers
      ++ ["}"]
  where codeChunks = groupsOf numBlocksPerMethod (Map.toList blocks)

groupsOf :: Int -> [a] -> [[a]]
groupsOf n [] = []
groupsOf n xs = let (grp,rest) = splitAt n xs
                in grp : groupsOf n rest
