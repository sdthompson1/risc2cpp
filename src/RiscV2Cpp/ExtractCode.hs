-- MODULE:
--   ExtractCode
--
-- PURPOSE:
--   Extracts code and data chunks, and a list of possible jump targets,
--   from an ELF binary. Also disassembles the code.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   9-Jun-2011
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2011.
--
--   This file is part of Mips2cs. Mips2cs is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Mips2cs.ExtractCode (extractCode) where

import Mips2cs.Mips
import Mips2cs.Misc

import Data.Bits
import qualified Data.ByteString as B
import Data.Elf
import Data.Int
import Data.List
import Data.Maybe
import Data.Ord
import qualified Data.Set as Set
import Data.Set (Set)
import Data.Word

-- return values:
--  1) list of jump targets (from reloc entries + entry point) -- does NOT include jal/bal return addrs (yet)
--  2) list of code chunks (list of addr + instruction pairs)
--  3) list of data chunks (each having base addr + list of Word32s). These are all of size 64K and 64K-aligned.
extractCode :: Elf -> ([Addr], [(Addr, Insn)], [(Addr, [Word32])] )
extractCode elf = 
    let allSections = sortBy (comparing elfSectionAddr) (elfSections elf)
        dataSections = filter isDataSection allSections
        codeSections = filter isCodeSection allSections
        codeChunks = makeCodeChunks codeSections
        dataChunks = makeDataChunks dataSections
        jumpTargets = findJumpTargets elf
    in (jumpTargets, codeChunks, dataChunks)


-- Checks whether a section should be included as "data"
isDataSection :: ElfSection -> Bool
isDataSection section = 
    let flags = elfSectionFlags section in
      (SHF_ALLOC `elem` flags) && (not (SHF_EXECINSTR `elem` flags))

-- Checks whether a section should be included as "code"
isCodeSection :: ElfSection -> Bool
isCodeSection section = 
    let flags = elfSectionFlags section in
      (SHF_ALLOC `elem` flags) && (SHF_EXECINSTR `elem` flags) -- && elfSectionName section == ".init"

-- Checks whether a section is going to be included in the final executable
isIncludedSection :: ElfSection -> Bool
isIncludedSection x = isDataSection x || isCodeSection x


makeDataChunks :: [ElfSection] -> [(Addr, [Word32])]
makeDataChunks sections =
    let inputChunks = map sectionToChunk sections
        paddedChunks = map ((padChunkEnd 16384) . (padChunkStart 16384)) inputChunks
        splitUpChunks = concatMap (splitChunk 16384) paddedChunks
        sorted = sortBy (comparing fst) splitUpChunks
    in mergeChunks sorted

-- Turn a section into a base address, list of Word32s, and length
sectionToChunk :: ElfSection -> (Addr, [Word32], Word32)
sectionToChunk section = ( fromIntegral (elfSectionAddr section)
                         , getWords section
                         , (fromIntegral (elfSectionSize section)) `quot` 4 )

-- Pad a chunk at the beginning to be aligned to chunkNumBytes
padChunkStart :: Word32 -> (Addr,[Word32],Word32) -> (Addr,[Word32],Word32)
padChunkStart chunkSizeWords (addr, words, len) =
    let paddingWords = (addr`quot`4) `rem` chunkSizeWords
    in ( addr - paddingWords * 4
       , genericTake paddingWords (repeat 0) ++ words
       , len + paddingWords )

-- Pad a chunk at the end to be a multiple of chunkNumBytes
padChunkEnd :: Word32 -> (Addr,[Word32],Word32) -> (Addr,[Word32],Word32)
padChunkEnd chunkSizeWords (addr, words, len) = 
    let paddingWords' = chunkSizeWords - (len `rem` chunkSizeWords)
        paddingWords = if paddingWords' == chunkSizeWords then 0 else paddingWords'
    in ( addr
       , words ++ genericTake paddingWords (repeat 0)
       , len + paddingWords )

-- Split a chunk (assumed padded at both ends) into multiple chunks of size exactly chunkSizeWords
splitChunk :: Word32 -> (Addr,[Word32],Word32) -> [(Addr,[Word32])]
splitChunk chunkSizeWords (addr, words, len)
    | len == chunkSizeWords
        = [(addr, words)]
    | len > chunkSizeWords
        = let (before, after) = genericSplitAt chunkSizeWords words
          in (addr, before) : splitChunk chunkSizeWords (addr + chunkSizeWords*4, after, len - chunkSizeWords)
    | otherwise
        = error $ "splitChunk: chunk size was not a multiple of " ++ show (chunkSizeWords * 4)

-- Merge adjacent chunks if they have the same start address.
mergeChunks :: [(Addr,[Word32])] -> [(Addr,[Word32])]
mergeChunks [] = []
mergeChunks [x] = [x]
mergeChunks (x:y:rest) | fst x /= fst y = x : mergeChunks (y:rest)
                       | otherwise      = mergeChunks ((mergeChunk x y) : rest)

-- The merge is done by taking the 'max' word from each chunk.
-- (This gets rid of any zero padding that might have made the chunks overlap.)
mergeChunk :: (Addr,[Word32]) -> (Addr,[Word32]) -> (Addr,[Word32])
mergeChunk (addr,w1) (_,w2) = (addr, map (\(a,b)->max a b) (zip w1 w2))


makeCodeChunks :: [ElfSection] -> [(Addr, Insn)]
makeCodeChunks = concatMap makeCodeChunk

makeCodeChunk :: ElfSection -> [(Addr, Insn)]
makeCodeChunk sec = 
    let startAddr = fromIntegral (elfSectionAddr sec)
        addrList = [startAddr, startAddr+4 ..]
        insns = map disassemble (getWords sec)
    in zip addrList insns

-- Read all the data words from a chunk. 
-- Expands out non-PROGBITS sections into a string of zeros. (In practice this means BSS sections.)
getWords :: ElfSection -> [Word32]
getWords section = case elfSectionType section of
                     SHT_PROGBITS -> toWordList (elfSectionData section)
                     _ -> genericTake ((elfSectionSize section) `div` 4) (repeat 0)

toWordList :: B.ByteString -> [Word32]
toWordList str =
    let bytes = B.unpack str
        fours = getFours bytes
    in map (\(a,b,c,d) -> (((fromIntegral a) `shiftL` 24) + ((fromIntegral b) `shiftL` 16) + ((fromIntegral c) `shiftL` 8) + (fromIntegral d))) fours
        where getFours [] = []
              getFours (a:b:c:d:rest) = (a,b,c,d) : getFours rest
              getFours _ = error "Section size is not a multiple of four"


findJumpTargets :: Elf -> [Addr]
findJumpTargets elf = filterJumpTargets elf (fromIntegral (elfEntry elf) : findJumpTargetsReloc elf)

-- Filter for addresses that are in the code segment only
filterJumpTargets :: Elf -> [Addr] -> [Addr]
filterJumpTargets elf = filter (isInCode (filter isCodeSection (elfSections elf)))

isInCode :: [ElfSection] -> Addr -> Bool
isInCode sections addr = or $ map (\s -> addrInSection addr s) sections

findJumpTargetsReloc :: Elf -> [Addr]
findJumpTargetsReloc elf = 
    let includedSections = filter isIncludedSection (elfSections elf)
        includedSectionNames = Set.fromList (map elfSectionName includedSections)
        relocSections = filter (isRelocSection includedSectionNames) (elfSections elf)
        relocTable = B.concat (map elfSectionData relocSections)
        relocEntries = extractRelocs relocTable
        gp = findGP elf
        relocItems = mapMaybe (processReloc gp includedSections) relocEntries
    in combineRelocs relocItems

-- extract gp value from the executable.
-- NOTE: This is a bit of a hack, we look for 'lui' and 'addiu' insns affecting the gp,
-- which are put there by my startup code in crt0.s.
findGP :: Elf -> Word32
findGP elf = 
    let codeSections = filter isCodeSection (elfSections elf)
        codeWords = concatMap getWords codeSections
    in sum (mapMaybe insnToGP codeWords)

insnToGP :: Word32 -> Maybe Word32
insnToGP insn 
    | insn .&. 0xfc1f0000 == 0x3c1c0000    -- LUI gp, ...
        = Just $ (insn .&. 0xffff) `shiftL` 16
    | insn .&. 0xffff0000 == 0x279c0000    -- ADDIU gp, gp, ...
        = Just $ signExtend1632 (insn .&. 0xffff)
    | otherwise 
        = Nothing

-- this decides which sections contain reloc entries
isRelocSection :: Set String -> ElfSection -> Bool
isRelocSection includedSectionNames sec = 
    -- We are interested in sections of type SHT_REL 
    -- with names of form .relXXX where XXX is the name of an included section
    elfSectionType sec == SHT_REL 
          && (take 4 (elfSectionName sec)) == ".rel" 
          && (drop 4 (elfSectionName sec)) `Set.member` includedSectionNames

-- return relocation entries of form (addr, info)
extractRelocs :: B.ByteString -> [(Word32, Word32)]
extractRelocs str 
    | B.null str = []
    | otherwise = 
        let (before, after) = B.splitAt 8 str
            (firstWord, secondWord) = B.splitAt 4 before
        in (strToWord firstWord, strToWord secondWord) : extractRelocs after

strToWord :: B.ByteString -> Word32
strToWord inp = 
    let [a,b,c,d] = map fromIntegral (B.unpack inp)
    in (a`shiftL`24) + (b`shiftL`16) + (c`shiftL`8) + d

data RelocItem = RAddr Word32 | RHi Word32 | RLo Word32

-- input: (addr, info) from reloc table
processReloc :: Word32 -> [ElfSection] -> (Word32, Word32) -> Maybe RelocItem
processReloc gp sections (addr, info) =
    let value = lookupWord sections addr
        value16 = value .&. 0xffff
        value16ext = signExtend1632 value16
        tag = info .&. 0xffffff00
    in case (info .&. 0xff) of
         2 -> Just $ RAddr value    -- R_MIPS_32
         4 -> Just $ RAddr $ (addr .&. 0xf0000000) .|. ((value .&. 0x07ffffff) `shiftL` 2)  -- R_MIPS_26
         5 -> Just $ RHi $ value16 `shiftL` 16    -- R_MIPS_HI16
         6 -> Just $ RLo $ value16ext             -- R_MIPS_LO16 (needs to be sign extended!)
         7 -> Just $ RAddr $ gp + value16ext      -- R_MIPS_GPREL16
         _ -> Nothing

combineRelocs :: [RelocItem] -> [Word32]
combineRelocs relocs = 
    let shifted = (tail relocs) ++ [RHi 0] -- dummy last entry.
    in mapMaybe combineReloc (zip relocs shifted)

combineReloc :: (RelocItem,RelocItem) -> Maybe Word32
combineReloc (item, following) = 
    case item of 
      RAddr a -> Just a
      RHi a -> case following of
                 RLo x -> Just $ a + x
                 _ -> Nothing  -- RHi w/o matching RLo; this is legal, and we should just ignore it.
      _ -> Nothing  -- RLo's are processed as part of the preceding RHi so do nothing here.

signExtend1632 :: Word32 -> Word32
signExtend1632 w32in =
    let w16 = (fromIntegral w32in)::Word16   -- drop top half
        i16 = (fromIntegral w16)::Int16    -- convert to signed
        i32 = (fromIntegral i16)::Int32    -- do sign extension
        w32out = (fromIntegral i32)::Word32  -- convert back to unsigned
    in w32out

-- look for a word in the executable
lookupWord :: [ElfSection] -> Word32 -> Word32
lookupWord sections addr =
    let sec = myFromJust $ find (addrInSection addr) sections
        byteString = elfSectionData sec
        offset = addr - fromIntegral (elfSectionAddr sec)
    in strToWord (B.take 4 (B.drop (fromIntegral offset) byteString))
          where myFromJust (Just x) = x
                myFromJust Nothing = error $ "lookupWord: addr " ++ toHex addr ++ " does not appear to be in the executable"

addrInSection :: Word32 -> ElfSection -> Bool
addrInSection addr section = 
    let base = fromIntegral (elfSectionAddr section)
        end = base + fromIntegral (elfSectionSize section)
    in addr >= base && addr < end
