-- MODULE:
--   Mips2cs.Intermediate
--
-- PURPOSE:
--   Intermediate language, consisting of Statements and Exprs.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   26-Dec-2010
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011.
--
--   This file is part of Mips2cs. Mips2cs is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Mips2cs.Intermediate
    ( VarName
    , RegName
    , Addr
    , runtimeErrorAddress
    , BinOp(..)
    , applyBinOp
    , isCommutative
    , isAssociative
    , UnOp(..)
    , applyUnOp
    , Expr(..)
    , MemOp(..)
    , Statement(..)
    , CondOp(..)
    , CondExpr(..)
    , applyCond
    , mapOverExprs       -- apply func to all Exprs in a Statement
    , mapOverExprsC      -- apply func to all Exprs in a CondExpr
    , mapOverCondExprs   -- apply func to all CondExprs in a Statement
    , findExprsInStmt
    , findExprsInCondExpr
    , findVarsInExpr
    )

where

import Data.Bits
import Data.Int
import Data.Word

type VarName = String
type RegName = String

type Addr = Word32

-- This address is jumped to when a runtime error is detected (e.g. a BREAK instruction)
runtimeErrorAddress :: Addr
runtimeErrorAddress = 0

-- Binary operators
-- At the moment, only 32-bit integer operators are supported.
data BinOp = Add
           | CheckedAdd
           | Sub
           | CheckedSub
           | Mult
           | MultU
           | MultHi
           | MultHiU
           | Quot
           | QuotU
           | Rem
           | RemU
           | And
           | Or
           | Xor
           | LogicalShiftLeft
           | LogicalShiftRight
           | ArithShiftRight
           | SetIfLess
           | SetIfLessU
     deriving (Show, Eq)

-- Useful functions for working with operators
applyBinOp :: BinOp -> Int32 -> Int32 -> Int32
applyBinOp Add = (+)
applyBinOp CheckedAdd = checked (+) (+)
applyBinOp Sub = (-)
applyBinOp CheckedSub = checked (-) (-)
applyBinOp Mult = (*)
applyBinOp MultHi = multFuncHi
applyBinOp MultU = unsigned (*)
applyBinOp MultHiU = unsigned multuFuncHi
applyBinOp Quot = quot
applyBinOp QuotU = unsigned quot
applyBinOp Rem = rem
applyBinOp RemU = unsigned rem
applyBinOp And = (.&.)
applyBinOp Or = (.|.)
applyBinOp Xor = xor
applyBinOp LogicalShiftLeft = shiftLeftFunc
applyBinOp LogicalShiftRight = unsigned shiftRightFunc
applyBinOp ArithShiftRight = shiftRightFunc
applyBinOp SetIfLess = setIfLessFunc
applyBinOp SetIfLessU = unsigned setIfLessFunc

isCommutative :: BinOp -> Bool
isCommutative Add = True
isCommutative CheckedAdd = True
isCommutative Sub = False
isCommutative CheckedSub = False
isCommutative Mult = True
isCommutative MultU = True
isCommutative MultHi = True
isCommutative MultHiU = True
isCommutative Quot = False
isCommutative QuotU = False
isCommutative Rem = False
isCommutative RemU = False
isCommutative And = True
isCommutative Or = True
isCommutative Xor = True
isCommutative LogicalShiftLeft = False
isCommutative LogicalShiftRight = False
isCommutative ArithShiftRight = False
isCommutative SetIfLess = False
isCommutative SetIfLessU = False

isAssociative :: BinOp -> Bool
isAssociative Add = True
isAssociative CheckedAdd = True
isAssociative Sub = False
isAssociative CheckedSub = False
isAssociative Mult = True
isAssociative MultU = True
isAssociative MultHi = False
isAssociative MultHiU = False
isAssociative Quot = False
isAssociative QuotU = False
isAssociative Rem = False
isAssociative RemU = False
isAssociative And = True
isAssociative Or = True
isAssociative Xor = True
isAssociative LogicalShiftLeft = False
isAssociative LogicalShiftRight = False
isAssociative ArithShiftRight = False
isAssociative SetIfLess = False
isAssociative SetIfLessU = False

-- Helper functions for the above
checked :: (Int32 -> Int32 -> Int32) -> (Int64 -> Int64 -> Int64) -> Int32 -> Int32 -> Int32
checked f32 f64 x32 y32 = 
    let x64 = fromIntegral x32 :: Int64
        y64 = fromIntegral y32 :: Int64
        sum32 = f32 x32 y32 :: Int32
        sum32as64 = fromIntegral sum32 :: Int64
        sum64 = f64 x64 y64 :: Int64
    in if sum32as64 == sum64 then sum32
       else error "Compile time overflow in checked instruction. Not supported."

unsigned :: (Word32 -> Word32 -> Word32) -> Int32 -> Int32 -> Int32
unsigned f x y = fromIntegral $ f (fromIntegral x :: Word32) (fromIntegral y :: Word32)

setIfLessFunc :: Integral a => a -> a -> a
setIfLessFunc x y = if x < y then 1 else 0

shiftLeftFunc :: (Bits a, Integral a) => a -> a -> a
shiftLeftFunc x y = x `shiftL` (fromIntegral y)

shiftRightFunc :: (Bits a, Integral a) => a -> a -> a
shiftRightFunc x y = x `shiftR` (fromIntegral y)

multFuncHi :: Int32 -> Int32 -> Int32
multFuncHi x y =
    let z :: Int64
        z = (fromIntegral x) * (fromIntegral y)
    in fromIntegral (z `shiftR` 32)  -- this should chop off top 32 bits, so arith vs logical shift doesn't matter.

multuFuncHi :: Word32 -> Word32 -> Word32
multuFuncHi x y = 
    let z :: Word64
        z = (fromIntegral x) * (fromIntegral y)
    in fromIntegral (z `shiftR` 32)


-- Unary operators
data UnOp = Negate
          | Not
            deriving (Show, Eq)

applyUnOp :: UnOp -> Int32 -> Int32
applyUnOp Negate = \x -> (-x)
applyUnOp Not = complement


-- Expressions
-- NOTE: Expressions never have 'write' side effects, although they may read memory and/or registers.
data Expr = LitExpr Int32
          | VarExpr VarName
          | UnExpr UnOp Expr
          | BinExpr BinOp Expr Expr
          | LoadMemExpr MemOp Expr    -- expr = the address.
          | LoadRegExpr RegName
            deriving (Eq, Show)

-- Types of memory load and store operations available.
-- Note: these can be used with unaligned addresses but the low bits will be implicitly masked out
-- e.g. a MemWord read from addr 3 will actually read from addr 0. This is exploited by the LWL, LWR implementations.
data MemOp = MemByte
           | MemByteU  -- used for loads only
           | MemHalf
           | MemHalfU  -- used for loads only
           | MemWord
             deriving (Eq, Show)

-- Statements
-- NOTE: Statements can have side effects, both 'write' (directly) and 'read' (via the Exprs they contain).
data Statement = Let VarName Expr           -- VarNames should be unique within a basic block
               | StoreMem MemOp Expr Expr   -- first expr = target addr; second expr = value to be stored
               | StoreReg RegName Expr
               | Jump CondExpr Addr Addr    -- if condition true, goto first addr, else goto second.
               | IndirectJump Expr
                 deriving (Eq, Show)

-- Conditional expressions, used for branches.
-- NOTE: CondOps are assumed to be signed, except where there is a U suffix.
data CondExpr = BinCond CondOp Expr Expr
              | LitCond Bool
                deriving (Eq, Show)

data CondOp = Equal
            | NotEqual
            | GtrThan
            | LessThan
            | GtrEqual
            | LessEqual
            | LessThanU
            | GtrEqualU
              deriving (Eq, Show)


-- Useful functions for working with CondExprs
applyCond :: CondOp -> Int32 -> Int32 -> Bool
applyCond Equal = (==)
applyCond NotEqual = (/=)
applyCond GtrThan = (>)
applyCond LessThan = (<)
applyCond GtrEqual = (>=)
applyCond LessEqual = (<=)
applyCond LessThanU = unsignedCond (<)
applyCond GtrEqualU = unsignedCond (>=)

unsignedCond :: (Word32->Word32->Bool) -> Int32 -> Int32 -> Bool
unsignedCond op a b = ((fromIntegral a)::Word32) `op` ((fromIntegral b)::Word32)


-- Mapping functions
-- Function to map over all the expressions in a statement.
mapOverExprs :: (Expr -> Expr) -> Statement -> Statement
mapOverExprs f (Let v e) = Let v (f e)
mapOverExprs f (StoreMem m e1 e2) = StoreMem m (f e1) (f e2)
mapOverExprs f (StoreReg n e) = StoreReg n (f e)
mapOverExprs f (Jump c a1 a2) = Jump (mapOverExprsC f c) a1 a2
mapOverExprs f (IndirectJump e) = IndirectJump (f e)

mapOverExprsC :: (Expr -> Expr) -> CondExpr -> CondExpr
mapOverExprsC f (BinCond op e1 e2) = BinCond op (f e1) (f e2)
mapOverExprsC f c@(LitCond _) = c

mapOverCondExprs :: (CondExpr -> CondExpr) -> Statement -> Statement
mapOverCondExprs f (Jump c a1 a2) = Jump (f c) a1 a2
mapOverCondExprs _ s = s

-- Finding functions
findExprsInStmt :: Statement -> [Expr]
findExprsInStmt (Let _ e) = [e]
findExprsInStmt (StoreMem _ e1 e2) = [e1, e2]
findExprsInStmt (StoreReg _ e) = [e]
findExprsInStmt (Jump c _ _) = findExprsInCondExpr c
findExprsInStmt (IndirectJump e) = [e]

findExprsInCondExpr :: CondExpr -> [Expr]
findExprsInCondExpr (BinCond _ e1 e2) = [e1, e2]
findExprsInCondExpr (LitCond _) = []

findVarsInExpr :: Expr -> [VarName]
findVarsInExpr (LitExpr _) = []
findVarsInExpr (VarExpr v) = [v]
findVarsInExpr (UnExpr _ e) = findVarsInExpr e
findVarsInExpr (BinExpr _ e1 e2) = findVarsInExpr e1 ++ findVarsInExpr e2
findVarsInExpr (LoadMemExpr _ e) = findVarsInExpr e
findVarsInExpr (LoadRegExpr _) = []
