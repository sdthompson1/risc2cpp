-- MODULE:
--   Mips2cs.Mips
--
-- PURPOSE:
--   Abstract representation of Mips assembly code. Includes a routine
--   to "disassemble" a Word32 into the abstract Insn type.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   25-Dec-2010
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011.
--
--   This file is part of Mips2cs. Mips2cs is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Mips2cs.Mips
    ( Addr
    , Reg(..)
    , Insn(..)
    , disassemble     -- Word32 -> Insn
    )

where

import Data.Bits
import Data.Int
import Data.Word

type Addr = Word32

-- this derives Enum, so we can use fromEnum to convert Reg to Int, or toEnum to convert Int to Reg.
data Reg = Zero
         | AT 
         | V0 | V1
         | A0 | A1 | A2 | A3
         | T0 | T1 | T2 | T3 | T4 | T5 | T6 | T7 
         | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7
         | T8 | T9
         | K0 | K1
         | GP
         | SP
         | S8
         | RA
           deriving (Show, Eq, Ord, Enum)


-- Instruction datatype.
--
-- Notes:
--
-- Most insns are represented in the obvious way, e.g. 
--   "ADD s0, s1, s2" is represented as "ADD S0 S1 S2"
--   "SW s0, 4(s1)" is represented as "SW S0 4 S1"
--   etc
--
-- Immediate values are always taken directly from the opcode, and not transformed
-- in any way, except for conversion to Int (either sign or zero extension is applied,
-- as appropriate for the opcode in question).

data Insn = ADD Reg Reg Reg
          | ADDI Reg Reg Int
          | ADDIU Reg Reg Int
          | ADDU Reg Reg Reg
          | AND Reg Reg Reg
          | ANDI Reg Reg Int
          | BEQ Reg Reg Int
          | BGEZ Reg Int
          | BGEZAL Reg Int
          | BGTZ Reg Int
          | BLEZ Reg Int
          | BLTZ Reg Int
          | BLTZAL Reg Int
          | BNE Reg Reg Int
          | BREAK
          | DIV Reg Reg
          | DIVU Reg Reg
          | J Int
          | JAL Int
          | JALR Reg Reg  -- First param = link reg, Second param = jump target reg
          | JR Reg
          | LB Reg Int Reg
          | LBU Reg Int Reg
          | LH Reg Int Reg
          | LHU Reg Int Reg
          | LUI Reg Int
          | LW Reg Int Reg
          | LWL Reg Int Reg
          | LWR Reg Int Reg
          | MFHI Reg
          | MFLO Reg
          | MTHI Reg
          | MTLO Reg
          | MULT Reg Reg
          | MULTU Reg Reg
          | NOP
          | NOR Reg Reg Reg
          | OR Reg Reg Reg
          | ORI Reg Reg Int
          | SB Reg Int Reg
          | SH Reg Int Reg
          | SLL Reg Reg Int
          | SLLV Reg Reg Reg
          | SLT Reg Reg Reg
          | SLTI Reg Reg Int
          | SLTIU Reg Reg Int
          | SLTU Reg Reg Reg
          | SRA Reg Reg Int
          | SRAV Reg Reg Reg
          | SRL Reg Reg Int
          | SRLV Reg Reg Reg
          | SUB Reg Reg Reg
          | SUBU Reg Reg Reg
          | SW Reg Int Reg
          | SWL Reg Int Reg
          | SWR Reg Int Reg
          | SYSCALL
          | XOR Reg Reg Reg
          | XORI Reg Reg Int
            deriving (Show)


disassemble :: Word32 -> Insn
disassemble insn = 
    let opcode :: Int
        opcode = fromIntegral ((insn `shiftR` 26) .&. 0xff)   -- the opcode is in bits 26-31
    in
      if opcode == 0 then decodeRType insn
      else if opcode == 2 || opcode == 3 then decodeJType insn opcode
           else if opcode >= 16 && opcode <= 19 then decodeCopper insn opcode
                else decodeIType insn opcode

-- 'R' type instructions (opcode 0)
decodeRType :: Word32 -> Insn
decodeRType insn = 
    let rs = decodeReg insn 21   -- bits 21-25
        rt = decodeReg insn 16   -- bits 16-20
        rd = decodeReg insn 11   -- bits 11-15
        shiftAmount = fromIntegral ((insn `shiftR` 6) .&. 0x1f)   -- bits 6-10: shift amount
        functionCode = insn .&. 0x3f    -- bits 0-5: function code
    in case functionCode of
         0 -> if insn == 0 then NOP
              else SLL rd rt shiftAmount
         2 -> SRL rd rt shiftAmount
         3 -> SRA rd rt shiftAmount
         4 -> SLLV rd rt rs
         6 -> SRLV rd rt rs
         7 -> SRAV rd rt rs
         8 -> JR rs
         9 -> JALR rd rs
         12 -> SYSCALL
         13 -> BREAK
         16 -> MFHI rd
         17 -> MTHI rs
         18 -> MFLO rd
         19 -> MTLO rs
         24 -> MULT rs rt
         25 -> MULTU rs rt
         26 -> DIV rs rt
         27 -> DIVU rs rt
         32 -> ADD rd rs rt
         33 -> ADDU rd rs rt
         34 -> SUB rd rs rt
         35 -> SUBU rd rs rt
         36 -> AND rd rs rt
         37 -> OR rd rs rt
         38 -> XOR rd rs rt
         39 -> NOR rd rs rt
         42 -> SLT rd rs rt
         43 -> SLTU rd rs rt
         _ -> error $ "Opcode 0 / function code " ++ (show functionCode) ++ " not supported"

-- 'I' type instructions
decodeIType :: Word32 -> Int -> Insn
decodeIType insn opcode = 
    let rs = decodeReg insn 21   -- bits 21-25
        rt = decodeReg insn 16   -- bits 16-20
        subcode = (insn `shiftR` 16) .&. 0x1f
        immediateS :: Int
        immediateS = fromIntegral (fromIntegral (insn .&. 0xffff) :: Int16) :: Int  -- Sign extend to Int
        immediateZ :: Int
        immediateZ = fromIntegral (fromIntegral (insn .&. 0xffff) :: Word16) :: Int  -- Zero extend to Int
    in case opcode of
         1 -> case subcode of
                0 -> BLTZ rs immediateS   -- branch offsets are always signed
                1 -> BGEZ rs immediateS
                16 -> BLTZAL rs immediateS
                17 -> BGEZAL rs immediateS
                _ -> error $ "Opcode 1 / subcode " ++ show subcode ++ " not supported"
         4 -> BEQ rs rt immediateS
         5 -> BNE rs rt immediateS
         6 -> BLEZ rs immediateS
         7 -> BGTZ rs immediateS
         8 -> ADDI rt rs immediateS  -- arithmetic instructions use sign extension
         9 -> ADDIU rt rs immediateS
         10 -> SLTI rt rs immediateS
         11 -> SLTIU rt rs immediateS  -- Note, sign extension is used, even though it is an unsigned compare...
         12 -> ANDI rt rs immediateZ   -- Logical instructions use zero extension
         13 -> ORI rt rs immediateZ
         14 -> XORI rt rs immediateZ
         15 -> LUI rt immediateS  -- could be immediateZ as well, doesn't really matter
         32 -> LB rt immediateS rs   -- memory offsets are always signed
         33 -> LH rt immediateS rs
         34 -> LWL rt immediateS rs
         35 -> LW rt immediateS rs
         36 -> LBU rt immediateS rs
         37 -> LHU rt immediateS rs
         38 -> LWR rt immediateS rs
         40 -> SB rt immediateS rs
         41 -> SH rt immediateS rs
         42 -> SWL rt immediateS rs
         43 -> SW rt immediateS rs
         46 -> SWR rt immediateS rs
         49 -> error "FPU operations (opcode 49) not supported"
         50 -> error "FPU operations (opcode 50) not supported"
         57 -> error "FPU operations (opcode 57) not supported"
         58 -> error "FPU operations (opcode 58) not supported"
         _ -> error $ "Opcode " ++ show opcode ++ " not supported"

-- 'J' type instructions (opcodes 2 and 3)
decodeJType :: Word32 -> Int -> Insn
decodeJType insn opcode = 
    let immediate = fromIntegral (insn .&. 0x03ffffff)  -- Zero extend
    in case opcode of
         2 -> J immediate
         3 -> JAL immediate
         _ -> error "Improper call to decodeJType"  -- decodeJType was called on a non J type insn!

-- Coprocessor instructions (opcodes 16, 17, 18, 19)
decodeCopper :: Word32 -> Int -> Insn
decodeCopper insn opcode = 
    error $ "Coprocessor instructions (opcode " ++ show opcode ++ ") not supported"


-- Helper functions

decodeReg :: Word32 -> Int -> Reg
decodeReg insn n = toEnum $ fromIntegral ((insn `shiftR` n) .&. 0x1f)
