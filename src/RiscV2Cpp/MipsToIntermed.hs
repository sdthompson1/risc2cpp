-- MODULE:
--   Mips2cs.MipsToIntermed
--
-- PURPOSE:
--   Converts Mips Insns to Intermediate Statements and Exprs.
--
-- AUTHOR:
--   Stephen Thompson <stephen@solarflare.org.uk>
--
-- CREATED:
--   27-Dec-2010
--
-- COPYRIGHT:
--   Copyright (C) Stephen Thompson, 2010 - 2011.
--
--   This file is part of Mips2cs. Mips2cs is distributed under the terms
--   of the Boost Software License, Version 1.0, the text of which
--   appears below.
--
--   Boost Software License - Version 1.0 - August 17th, 2003
--   
--   Permission is hereby granted, free of charge, to any person or organization
--   obtaining a copy of the software and accompanying documentation covered by
--   this license (the "Software") to use, reproduce, display, distribute,
--   execute, and transmit the Software, and to prepare derivative works of the
--   Software, and to permit third-parties to whom the Software is furnished to
--   do so, all subject to the following:
--
--   The copyright notices in the Software and this entire statement, including
--   the above license grant, this restriction and the following disclaimer,
--   must be included in all copies of the Software, in whole or in part, and
--   all derivative works of the Software, unless such copies or derivative
--   works are solely in the form of machine-executable object code generated by
--   a source language processor.
--
--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
--   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
--   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
--   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--   DEALINGS IN THE SOFTWARE.


module Mips2cs.MipsToIntermed
    ( mipsToIntermed  -- [Addr] -> [(Addr, [Insn])] -> ([Addr], [(Addr, [Statement])])
    )

where

import Mips2cs.Mips hiding (Addr)   -- TODO: should Addr be in some common module? What about 64 bit vs 32 bit machines?
import Mips2cs.Misc
import Mips2cs.Intermediate

import Data.Bits
import Data.Char
import Data.Int
import Data.List
import qualified Data.Map as Map
import Data.Map (Map)
import Data.Maybe
import Data.Word


-- Register names
getRegName :: Reg -> RegName
getRegName Zero = error "regName Zero"
getRegName r = map toLower (show r)

hiRegName :: RegName
hiRegName = "hi"

loRegName :: RegName
loRegName = "lo"

-- This is a "fake register" used in the translation 
-- of LWL, LWR, SWL, SWR instructions.
shiftTempName :: RegName
shiftTempName = "shift_amount"

-- Find an expr corresponding to the given register
loadReg :: Reg -> Expr
loadReg Zero = LitExpr 0
loadReg reg = LoadRegExpr (getRegName reg) 

-- Make an Expr out of an immediate Int value
-- NOTE: This will sign extend the value to Int32
immediate :: Int -> Expr
immediate = LitExpr . fromIntegral

-- construct a StoreReg from a BinOp applied to two regs
makeBin :: BinOp -> Reg -> Reg -> Reg -> [Statement]
makeBin op dest src1 src2 = [StoreReg (getRegName dest) (BinExpr op (loadReg src1) (loadReg src2))]

-- construct a StoreReg from a BinOp applied to a Reg and an immediate value
makeBinI :: BinOp -> Reg -> Reg -> Int -> [Statement]
makeBinI op dest srcR srcI = [StoreReg (getRegName dest) (BinExpr op (loadReg srcR) (immediate srcI))]

-- construct a StoreReg statement for an LUI instruction
makeLUI :: Reg -> Int -> [Statement]
makeLUI reg value = [StoreReg (getRegName reg) (LitExpr val)]
    where val :: Int32
          val = (fromIntegral value) `shiftL` 16

-- construct a StoreReg for a NOR instruction (requires combination of ~ and | operators)
makeNOR :: Reg -> Reg -> Reg -> [Statement]
makeNOR dest src1 src2 = [StoreReg (getRegName dest) (UnExpr Not (BinExpr Or (loadReg src1) (loadReg src2)))]

-- construct a StoreReg statement for a load from memory.
makeLoad :: Reg -> MemOp -> Int -> Reg -> [Statement]
makeLoad destReg op offset addrReg = 
    [StoreReg (getRegName destReg) (LoadMemExpr op (BinExpr Add (immediate offset) (loadReg addrReg)))]

-- LWL and LWR loads are "synthesized" from primitive operations.
loadWordLeft :: Reg -> Int -> Reg -> [Statement]
loadWordLeft destReg offset addrReg = 
    let addrExpr = BinExpr Add (immediate offset) (loadReg addrReg)  -- The address to be read
        loadExpr = LoadMemExpr MemWord addrExpr   -- The aligned word read in.
        inputExpr = loadReg destReg               -- The original value in the dest register
        shiftExpr = BinExpr LogicalShiftLeft      -- (addr&3)<<3. Aligned wd must be shifted left this amt.
                             (BinExpr And addrExpr (LitExpr 3)) 
                             (LitExpr 3) 
        inputMask = BinExpr Sub                   -- ((1<<shift)-1). Input must be masked by this.
                             (BinExpr LogicalShiftLeft (LitExpr 1) (LoadRegExpr shiftTempName))
                             (LitExpr 1)               
        leftExpr = BinExpr And inputExpr inputMask     -- inputReg & inputMask (i.e., the part of the input register to be kept.)
        rightExpr = BinExpr LogicalShiftLeft loadExpr (LoadRegExpr shiftTempName)   -- unalignedWord << shift
        finalExpr = BinExpr Or leftExpr rightExpr      -- left | right
    in [StoreReg shiftTempName shiftExpr, StoreReg (getRegName destReg) finalExpr]

loadWordRight :: Reg -> Int -> Reg -> [Statement]
loadWordRight destReg offset addrReg =
    let addrExpr = BinExpr Add (immediate offset) (loadReg addrReg)  -- The address to be read
        loadExpr = LoadMemExpr MemWord addrExpr        -- The aligned word read in.
        inputExpr = loadReg destReg                    -- The original value in the dest register
        shiftExpr = BinExpr LogicalShiftLeft (BinExpr And addrExpr (LitExpr 3)) (LitExpr 3)  -- ((addr&3)<<3)
        inputMask = BinExpr LogicalShiftLeft (LitExpr 0xffffff00) (LoadRegExpr shiftTempName)
        leftExpr = BinExpr And inputExpr inputMask
        rightExpr = BinExpr LogicalShiftRight loadExpr (BinExpr Sub (LitExpr 24) (LoadRegExpr shiftTempName))
        finalExpr = BinExpr Or leftExpr rightExpr
    in [StoreReg shiftTempName shiftExpr, StoreReg (getRegName destReg) finalExpr]

storeWordLeft :: Reg -> Int -> Reg -> [Statement]
storeWordLeft srcReg offset addrReg 
    = unalignedStore srcReg offset addrReg 
         (BinExpr LogicalShiftLeft (LitExpr 0xffffff00) (BinExpr Sub (LitExpr 24) (LoadRegExpr shiftTempName)))
         (BinExpr LogicalShiftRight (loadReg srcReg) (LoadRegExpr shiftTempName))

storeWordRight :: Reg -> Int -> Reg -> [Statement]
storeWordRight srcReg offset addrReg 
    = unalignedStore srcReg offset addrReg
         (BinExpr ArithShiftRight (LitExpr 0xffffff) (LoadRegExpr shiftTempName))
         (BinExpr LogicalShiftLeft (loadReg srcReg) (BinExpr Sub (LitExpr 24) (LoadRegExpr shiftTempName)))

unalignedStore :: Reg -> Int -> Reg -> Expr -> Expr -> [Statement]
unalignedStore srcReg offset addrReg expr1 expr2 = 
    let addrExpr = BinExpr Add (immediate offset) (loadReg addrReg)  -- The address
        loadExpr = LoadMemExpr MemWord addrExpr  -- The aligned word read in
        regExpr = loadReg srcReg        -- The register being written out to memory
        shiftExpr = BinExpr LogicalShiftLeft (BinExpr And addrExpr (LitExpr 3)) (LitExpr 3)  -- (addr&3)<<3
        leftExpr = BinExpr And loadExpr expr1
    in [StoreReg shiftTempName shiftExpr
       ,StoreMem MemWord addrExpr (BinExpr Or leftExpr expr2)]

-- construct two StoreReg exprs for a MULT or DIV instruction.
makeHilo :: BinOp -> BinOp -> Reg -> Reg -> [Statement]
makeHilo opHi opLo src1 src2 =
    let srcExp1 = loadReg src1
        srcExp2 = loadReg src2
    in [StoreReg hiRegName (BinExpr opHi srcExp1 srcExp2)
       ,StoreReg loRegName (BinExpr opLo srcExp1 srcExp2)]

-- construct a StoreMem statement
mkStore :: Reg -> MemOp -> Int -> Reg -> [Statement]
mkStore srcReg op offset addrReg = 
    let srcExpr = loadReg srcReg
        addrExpr = BinExpr Add (immediate offset) (loadReg addrReg)
    in [StoreMem op addrExpr srcExpr]

-- Converts a non-branch instruction into 0, 1 or 2 Statements.
convertNormalInsn :: Insn -> [Statement]
convertNormalInsn (ADD dest src1 src2) = makeBin CheckedAdd dest src1 src2
convertNormalInsn (ADDI dest srcR srcI) = makeBinI CheckedAdd dest srcR srcI
convertNormalInsn (ADDIU dest srcR srcI) = makeBinI Add dest srcR srcI
convertNormalInsn (ADDU dest src1 src2) = makeBin Add dest src1 src2
convertNormalInsn (AND dest src1 src2) = makeBin And dest src1 src2
convertNormalInsn (ANDI dest srcR srcI) = makeBinI And dest srcR srcI
convertNormalInsn (BREAK) = [Jump (LitCond True) runtimeErrorAddress 0]
convertNormalInsn (DIV src1 src2) = makeHilo Rem Quot src1 src2
convertNormalInsn (DIVU src1 src2) = makeHilo RemU QuotU src1 src2
convertNormalInsn (LB dest offset areg) = makeLoad dest MemByte offset areg
convertNormalInsn (LBU dest offset areg) = makeLoad dest MemByteU offset areg
convertNormalInsn (LH dest offset areg) = makeLoad dest MemHalf offset areg
convertNormalInsn (LHU dest offset areg) = makeLoad dest MemHalfU offset areg
convertNormalInsn (LUI dest value) = makeLUI dest value
convertNormalInsn (LW dest offset areg) = makeLoad dest MemWord offset areg
convertNormalInsn (LWL dest offset areg) = loadWordLeft dest offset areg
convertNormalInsn (LWR dest offset areg) = loadWordRight dest offset areg
convertNormalInsn (MFHI dest) = [StoreReg (getRegName dest) (LoadRegExpr hiRegName)]
convertNormalInsn (MFLO dest) = [StoreReg (getRegName dest) (LoadRegExpr loRegName)]
convertNormalInsn (MTHI src) = [StoreReg hiRegName (loadReg src)]
convertNormalInsn (MTLO src) = [StoreReg loRegName (loadReg src)]
convertNormalInsn (MULT src1 src2) = makeHilo MultHi Mult src1 src2
convertNormalInsn (MULTU src1 src2) = makeHilo MultHiU MultU src1 src2
convertNormalInsn (NOP) = []
convertNormalInsn (NOR dest src1 src2) = makeNOR dest src1 src2
convertNormalInsn (OR dest src1 src2) = makeBin Or dest src1 src2
convertNormalInsn (ORI dest srcR srcI) = makeBinI Or dest srcR srcI
convertNormalInsn (SB src offset areg) = mkStore src MemByte offset areg
convertNormalInsn (SH src offset areg) = mkStore src MemHalf offset areg
convertNormalInsn (SLL dest src amount) = makeBinI LogicalShiftLeft dest src amount
convertNormalInsn (SLLV dest src amount) = makeBin LogicalShiftLeft dest src amount
convertNormalInsn (SLT dest src1 src2) = makeBin SetIfLess dest src1 src2
convertNormalInsn (SLTI dest srcR srcI) = makeBinI SetIfLess dest srcR srcI
convertNormalInsn (SLTIU dest srcR srcI) = makeBinI SetIfLessU dest srcR srcI
convertNormalInsn (SLTU dest src1 src2) = makeBin SetIfLessU dest src1 src2
convertNormalInsn (SRA dest src amount) = makeBinI ArithShiftRight dest src amount
convertNormalInsn (SRAV dest src amount) = makeBin ArithShiftRight dest src amount
convertNormalInsn (SRL dest src amount) = makeBinI LogicalShiftRight dest src amount
convertNormalInsn (SRLV dest src amount) = makeBin LogicalShiftRight dest src amount
convertNormalInsn (SUB dest src1 src2) = makeBin CheckedSub dest src1 src2
convertNormalInsn (SUBU dest src1 src2) = makeBin Sub dest src1 src2
convertNormalInsn (SW src offset areg) = mkStore src MemWord offset areg
convertNormalInsn (SWL src offset areg) = storeWordLeft src offset areg
convertNormalInsn (SWR src offset areg) = storeWordRight src offset areg
convertNormalInsn (SYSCALL) = error "SYSCALL not supported currently"
convertNormalInsn (XOR dest src1 src2) = makeBin Xor dest src1 src2
convertNormalInsn (XORI dest srcR srcI) = makeBinI Xor dest srcR srcI
convertNormalInsn _ = error "Wrong instruction passed to convertNormalInsn"


-- Check to see if an instruction is a jump instruction, and if so, return an appropriate Jump or IndirectJump statement.
-- Note: Reads from dummy variables to prevent delay slot problems.
getJumpStmt :: Addr -> Insn -> Maybe Statement
getJumpStmt pc (BEQ r1 r2 offset) = pcRelative pc offset (BinCond Equal (VarExpr "delay1") (VarExpr "delay2"))
getJumpStmt pc (BGEZ r offset)    = pcRelative pc offset (BinCond GtrEqual (VarExpr "delay1") (LitExpr 0))
getJumpStmt pc (BGEZAL r offset)  = pcRelative pc offset (BinCond GtrEqual (VarExpr "delay1") (LitExpr 0))
getJumpStmt pc (BGTZ r offset)    = pcRelative pc offset (BinCond GtrThan (VarExpr "delay1") (LitExpr 0))
getJumpStmt pc (BLEZ r offset)    = pcRelative pc offset (BinCond LessEqual (VarExpr "delay1") (LitExpr 0))
getJumpStmt pc (BLTZ r offset)    = pcRelative pc offset (BinCond LessThan (VarExpr "delay1") (LitExpr 0))
getJumpStmt pc (BLTZAL r offset)  = pcRelative pc offset (BinCond LessThan (VarExpr "delay1") (LitExpr 0))
getJumpStmt pc (BNE r1 r2 offset) = pcRelative pc offset (BinCond NotEqual (VarExpr "delay1") (VarExpr "delay2"))
getJumpStmt pc (J target)         = pcRegion pc target
getJumpStmt pc (JAL target)       = pcRegion pc target
getJumpStmt pc (JALR _ target)    = Just $ IndirectJump (VarExpr "delay1")
getJumpStmt pc (JR target)        = Just $ IndirectJump (VarExpr "delay1")
getJumpStmt _  _                  = Nothing

pcRelative :: Addr -> Int -> CondExpr -> Maybe Statement
pcRelative pc offset cond = Just $ Jump cond (pc + ((fromIntegral offset) `shiftL` 2) + 4) (pc + 8)

pcRegion :: Addr -> Int -> Maybe Statement
pcRegion pc target = Just $ Jump (LitCond True) (((pc+4) .&. 0xf0000000) .|. ((fromIntegral target) `shiftL` 2)) 0

getLinkStmts :: Addr -> Insn -> [Statement]
getLinkStmts pc i =
    case getLinkRegister i of
      Nothing -> []
      Just linkReg -> [StoreReg (getRegName linkReg) (LitExpr (fromIntegral (pc+8)))]  -- converts link addr to Int32

getLinkRegister :: Insn -> Maybe Reg
getLinkRegister (BGEZAL _ _) = Just RA
getLinkRegister (BLTZAL _ _) = Just RA
getLinkRegister (JAL _) = Just RA
getLinkRegister (JALR reg _) = Just reg
getLinkRegister _ = Nothing

-- Extra Lets are needed for branch instructions to avoid mistakes with delay slots.
-- We create dummy variables, named "delay1" (and maybe "delay2") to deal with this.
getLetsNeeded :: Insn -> [Reg]
getLetsNeeded (BEQ r1 r2 _) = [r1, r2]
getLetsNeeded (BGEZ r1 _) = [r1]
getLetsNeeded (BGEZAL r1 _) = [r1]
getLetsNeeded (BGTZ r1 _) = [r1]
getLetsNeeded (BLEZ r1 _) = [r1]
getLetsNeeded (BLTZ r1 _) = [r1]
getLetsNeeded (BLTZAL r1 _) = [r1]
getLetsNeeded (BNE r1 r2 _) = [r1, r2]
getLetsNeeded (J _) = []
getLetsNeeded (JAL _) = []
getLetsNeeded (JALR _ r) = [r]  -- The dest register (NOT the link reg as that is being written, not read.)
getLetsNeeded (JR r) = [r]

-- Generating the required Let stmts
generateLetsForBranch :: Insn -> [Statement]
generateLetsForBranch i = 
    let regsToSave = getLetsNeeded i :: [Reg]
    in map f (zip regsToSave [1..])
        where f (reg, n) = let varName = "delay" ++ show n
                               regExpr = loadReg reg
                           in Let varName regExpr  -- Assign to the dummy variable.

-- Converting delay slot instructions
convertDelaySlot :: Maybe Insn -> [Statement]
convertDelaySlot Nothing = error "Missing delay slot"
convertDelaySlot (Just BREAK) = error "BREAK in delay slot, not supported"
convertDelaySlot (Just insn) = case getJumpStmt 0 insn of 
                                 Just _ -> error "Jump or branch insn in delay slot, not supported"
                                 Nothing -> convertNormalInsn insn

-- Master routine to convert one Insn into a list of Statements.
-- May convert the following Insn as well (delay slot).
convertInsn :: (Addr, Insn, Maybe Insn) -> (Addr, [Statement])
convertInsn (addr, insn, delay) = 
    case getJumpStmt addr insn of
      Just jumpStmt ->                              -- Reads the dummy variables
          let letStmts = generateLetsForBranch insn -- Copies the normal regs into the dummy variables
              linkStmts = getLinkStmts addr insn    -- Reads the normal regs
              delayStmts = convertDelaySlot delay
          in (addr, letStmts ++ linkStmts ++ delayStmts ++ [jumpStmt])
      Nothing ->
          (addr, convertNormalInsn insn)


-- Convert a list of instructions into a list of (Addr,[Statement]) pairs
-- We assume the insns are sorted by address.
convertAllInsns :: [(Addr, Insn)] -> [(Addr, [Statement])]
convertAllInsns insns = 
    let delays = tail insns ++ [(0,NOP)]
        combineFunc (addr, insn) (addr2, delay) 
            | addr2 == addr + 4 = (addr, insn, Just delay)
            | otherwise         = (addr, insn, Nothing)
        addrInsnDelay = zipWith combineFunc insns delays  :: [(Addr, Insn, Maybe Insn)]
    in map convertInsn addrInsnDelay


-- Finding indirect jumps from Link instructions
insnLinkTarget :: (Addr, Insn) -> Maybe Addr
insnLinkTarget (addr, insn) = case getLinkRegister insn of
                                Just _ -> Just (addr+8)
                                Nothing -> Nothing


-- The master routine to convert Mips code into the Intermediate language.
-- Inputs:
--   * indirect jumps, from relocs only. (not necessarily sorted.)
--   * instructions, as (Addr, Insn) pairs. (assumed sorted -- so can find delay slots easily)
-- Output:
--   * indirect jumps, all. (sorted, unique.)
--   * the converted Statements for each address.
mipsToIntermed :: [Addr] -> [(Addr, Insn)] -> ([Addr], [(Addr, [Statement])])
mipsToIntermed inputIndirectTargets insns = 
    let linkTargets = catMaybes $ map insnLinkTarget insns
        allIndirectTargets = (uniq . sort) (linkTargets ++ inputIndirectTargets) -- sorted
        convertedInsns = convertAllInsns insns
    in (allIndirectTargets, convertedInsns)
